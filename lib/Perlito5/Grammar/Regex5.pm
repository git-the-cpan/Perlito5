# Do not edit this file - Generated by Perlito5 9.014

{
    package main;
    package Perlito5::Grammar::Regex5;
    use strict;
    use warnings;
    our $CAPTURE_ID = 0;
    sub Perlito5::Grammar::Regex5::any {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::string_of_code {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            my $count = 0;
            while ((do {
                my $pos1 = $MATCH->{'to'};
                (do {
                    ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = string_of_code($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    ((do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {
                    $last_match_null = $last_match_null + 1
                }
                else {
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::quotemeta {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                my $res = ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('E' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {
                    $last_match_null = $last_match_null + 1
                }
                else {
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'}
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            1
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::posix_character_class {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('alpha' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('alnum' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('ascii' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('blank' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('cntrl' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('digit' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('graph' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('lower' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('print' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('punct' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('space' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('upper' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('word' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('xdigit' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::character {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $tmp = $MATCH;
            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
            my $res = (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $m2 = any($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'any'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = {'character' => Perlito5::Match::flat($MATCH->{'any'})};
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::character2 {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $tmp = $MATCH;
            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
            my $res = (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $m2 = any($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'any'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = {'character' => Perlito5::Match::flat($MATCH->{'any'})};
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::character_class {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('[:' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                    my $m2 = posix_character_class($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'posix_character_class'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (':]' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = {'posix_character_class' => Perlito5::Match::flat($MATCH->{'posix_character_class'})};
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('[:^' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                    my $m2 = posix_character_class($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'posix_character_class'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (':]' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = {'negated_posix_character_class' => Perlito5::Match::flat($MATCH->{'posix_character_class'})};
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = character($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'character'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = character2($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'character2'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = {'character_range' => [Perlito5::Match::flat($MATCH->{'character'}), Perlito5::Match::flat($MATCH->{'character2'})]};
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'character'});
                            1
                        })
                    })
                }))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::character_class_list {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = character_class($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'character_class'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = character_class_list($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'character_class_list'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'character_class'}), @{Perlito5::Match::flat($MATCH->{'character_class_list'})}];
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'character_class'})];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = [];
                    1
                })
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::verb {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('PRUNE' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('SKIP' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('MARK' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('THEN' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('COMMIT' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('FAIL' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('F' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('ACCEPT' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::rule_term {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('^' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = 'beginning_of_line';
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = 'end_of_line';
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = 'any';
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'positive_look_ahead' => Perlito5::Match::flat($MATCH->{'rule'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('!' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'negative_look_ahead' => Perlito5::Match::flat($MATCH->{'rule'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'possessive_quantifier' => Perlito5::Match::flat($MATCH->{'rule'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('<=' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'positive_look_behind' => Perlito5::Match::flat($MATCH->{'rule'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('<!' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'negative_look_behind' => Perlito5::Match::flat($MATCH->{'rule'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture_id'} = ++$CAPTURE_ID;
                                    1
                                }) && ('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('>' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'named_capture' => {'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), 'term' => Perlito5::Match::flat($MATCH->{'rule'}), 'id' => $MATCH->{'capture_id'}}};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = string_of_code($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'string_of_code'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'code' => Perlito5::Match::flat($MATCH->{'string_of_code'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('?{' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $m2 = string_of_code($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'string_of_code'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'postponed_code' => Perlito5::Match::flat($MATCH->{'string_of_code'})};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while (((do {
                                        my $tmp = $MATCH;
                                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                        my $res = (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                        $MATCH = $tmp;
                                        $res ? 0 : 1
                                    }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = 'comment';
                                    1
                                }))
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'verb' => {'tag' => 'MARK', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'})}};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = verb($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'verb'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = {'verb' => {'tag' => Perlito5::Match::flat($MATCH->{'verb'}), 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'})}};
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = {'verb' => {'tag' => Perlito5::Match::flat($MATCH->{'verb'})}};
                                            1
                                        })
                                    })
                                }))
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture_id'} = ++$CAPTURE_ID;
                            1
                        }) && (do {
                            my $m2 = rule($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'rule'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = {'capture' => {'term' => Perlito5::Match::flat($MATCH->{'rule'}), 'id' => $MATCH->{'capture_id'}}};
                            1
                        }))
                    })
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            die('Unmatched ( in regex');
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((chr(92) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ((do {
                    my $m2 = any($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'any'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = {'special_character' => Perlito5::Match::flat($MATCH->{'any'})};
                    1
                })))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('^' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = character_class_list($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'character_class_list'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'negated_character_class' => [{'character' => ']'}, @{Perlito5::Match::flat($MATCH->{'character_class_list'})}]};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = character_class_list($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'character_class_list'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = {'negated_character_class' => Perlito5::Match::flat($MATCH->{'character_class_list'})};
                                    1
                                }))
                            })
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = character_class_list($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'character_class_list'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = {'character_class' => [{'character' => ']'}, @{Perlito5::Match::flat($MATCH->{'character_class_list'})}]};
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = character_class_list($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'character_class_list'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = {'character_class' => Perlito5::Match::flat($MATCH->{'character_class_list'})};
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            die('Unmatched [ in regex');
                            1
                        })
                    })
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            die('Unmatched [ in regex');
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = (do {
                        my $pos1 = $MATCH->{'to'};
                        (do {
                            (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ('|' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                        })
                    });
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && (do {
                    my $m2 = any($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'any'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = {'character' => Perlito5::Match::flat($MATCH->{'any'})};
                    1
                }))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::quant_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((',' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((',' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    })
                }))
            })
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                1
            })
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::quantifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = rule_term($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'rule_term'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = quant_exp($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'quant_exp'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = {'quantifier' => {'term' => Perlito5::Match::flat($MATCH->{'rule_term'}), 'quant' => Perlito5::Match::flat($MATCH->{'quant_exp'})}};
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule_term'});
                    1
                })
            })
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::concat_list {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = quantifier($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'quantifier'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = concat_list($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'concat_list'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'}), @{Perlito5::Match::flat($MATCH->{'concat_list'})}];
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'})];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = [];
                    1
                })
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::concat_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = concat_list($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'concat_list'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            my $arg = Perlito5::Match::flat($MATCH->{'concat_list'});
            if (@{$arg} < 1) {
                $MATCH->{'capture'} = 'empty'
            }
            elsif (@{$arg} < 2) {
                ($MATCH->{'capture'}) = @{$arg}
            }
            else {
                $MATCH->{'capture'} = {'concat_list' => $arg}
            }
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::or_list_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = concat_exp($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'concat_exp'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('|' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = or_list_exp($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'or_list_exp'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'}), @{Perlito5::Match::flat($MATCH->{'or_list_exp'})}];
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'})];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = [];
                    1
                })
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Regex5::rule {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = or_list_exp($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'or_list_exp'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            my $arg = Perlito5::Match::flat($MATCH->{'or_list_exp'});
            if (@{$arg} < 1) {
                $MATCH->{'capture'} = 'empty'
            }
            elsif (@{$arg} < 2) {
                ($MATCH->{'capture'}) = @{$arg}
            }
            else {
                $MATCH->{'capture'} = {'or_list' => $arg}
            }
            1
        })));
        $tmp ? $MATCH : 0
    }
}
;1
