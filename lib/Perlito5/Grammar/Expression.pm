# Do not edit this file - Generated by Perlito5 9.009
{
    package main;
    package Perlito5::Grammar::Expression;
    {
        {
            package main;
            package Perlito5::Grammar::Precedence;
            {
                {
                    package main;
                    package feature;
                    sub feature::import {}
                    sub feature::unimport {}
                    1
                }
            }
            sub Perlito5::Grammar::Precedence::new {
                my $class = shift;
                bless({@_}, $class)
            }
            my $Operator = {};
            my $Precedence = {};
            my $PrefixPrecedence = {};
            my $Assoc = {};
            sub Perlito5::Grammar::Precedence::is_assoc_type {
                my $assoc_type = shift;
                my $op_name = shift;
                return $Assoc->{$assoc_type}->{$op_name}
            }
            sub Perlito5::Grammar::Precedence::is_fixity_type {
                my $fixity_type = shift;
                my $op_name = shift;
                return $Operator->{$fixity_type}->{$op_name}
            }
            sub Perlito5::Grammar::Precedence::is_term {
                my $token = shift;
                ($token->[0] eq 'term') || ($token->[0] eq 'postfix_or_term') || ($token->[0] eq 'postfix')
            }
            sub Perlito5::Grammar::Precedence::is_num {
                $_[0] ge 0 && $_[0] le 9
            }
            sub Perlito5::Grammar::Precedence::is_ident_middle {
                my $c = shift;
                ($c ge 'a' && $c le 'z') || ($c ge 0 && $c le 9) || ($c eq '_')
            }
            my @Parsed_op_chars = (2, 1);
            my %Parsed_op = ('?' => sub {
                Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
            }, '(' => sub {
                Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
            }, '[' => sub {
                Perlito5::Grammar::Expression::term_square($_[0], $_[1])
            }, '{' => sub {
                Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
            }, '->' => sub {
                Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
            });
            my @Term_chars;
            my %Term;
            sub Perlito5::Grammar::Precedence::add_term {
                my $name = shift;
                my $param = shift;
                $Term{$name} = $param;
                unshift(@Term_chars, scalar(@Term_chars) + 1)
                    while @Term_chars < length($name)
            }
            my $End_token;
            my $End_token_chars;
            my %Op;
            my @Op_chars = (3, 2, 1);
            sub Perlito5::Grammar::Precedence::op_parse {
                my $str = shift;
                my $pos = shift;
                my $last_is_term = shift;
                for my $len (@{$End_token_chars}) {
                    my $term = substr($str, $pos, $len);
                    if (exists($End_token->{$term})) {
                        my $c1 = substr($str, $pos + $len - 1, 1);
                        my $c2 = substr($str, $pos + $len, 1);
                        if (!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '<' && $c2 eq '<')) {
                            return {'str' => $str, 'from' => $pos, 'to' => $pos, 'capture' => ['end', $term]}
                        }
                    }
                }
                if (!$last_is_term) {
                    for my $len (@Term_chars) {
                        my $term = substr($str, $pos, $len);
                        if (exists($Term{$term})) {
                            my $c1 = substr($str, $pos + $len - 1, 1);
                            my $c2 = substr($str, $pos + $len, 1);
                            if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                                my $m = $Term{$term}->($str, $pos);
                                $m && return $m
                            }
                        }
                    }
                }
                for my $len (@Parsed_op_chars) {
                    my $op = substr($str, $pos, $len);
                    if (exists($Parsed_op{$op})) {
                        my $m = $Parsed_op{$op}->($str, $pos);
                        $m && return $m
                    }
                }
                for my $len (@Op_chars) {
                    my $op = substr($str, $pos, $len);
                    if (exists($Op{$op})) {
                        my $c1 = substr($str, $pos + $len - 1, 1);
                        my $c2 = substr($str, $pos + $len, 1);
                        if ((!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '&' && $c2 eq '&')) || ($c1 eq 'x' && $c2 ge 0 && $c2 le 9)) {
                            if (exists($Operator->{'infix'}->{$op}) && !exists($Operator->{'prefix'}->{$op}) && !$last_is_term) {}
                            else {
                                return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['op', $op]}
                            }
                        }
                    }
                }
                return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
            }
            sub Perlito5::Grammar::Precedence::add_op {
                my($fixity, $names, $precedence, $param) = @_;
                $param //= {};
                my $assoc = $param->{'assoc'} || 'left';
                for my $name (@{$names}) {
                    $Operator->{$fixity}->{$name} = 1;
                    $Precedence->{$name} = $precedence;
                    $fixity eq 'prefix' && ($PrefixPrecedence->{$name} = $precedence);
                    $Assoc->{$assoc}->{$name} = 1;
                    $Op{$name} = 1
                }
            }
            my $prec = 100;
            add_op('postfix', ['.( )', '.[ ]', '.{ }', '( )', '[ ]', 'funcall', 'funcall_no_params', 'methcall', 'methcall_no_params', 'block', 'hash'], $prec);
            $prec = $prec - 1;
            add_op('prefix', ['++', '--'], $prec);
            add_op('postfix', ['++', '--'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['**'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('prefix', [chr(92), '+', '-', '~', '!'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['=~', '!~'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['*', '/', '%', 'x'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['+', '-'], $prec);
            add_op('infix', ['.'], $prec, {'assoc' => 'list'});
            $prec = $prec - 1;
            add_op('infix', ['<<', '>>'], $prec);
            $prec = $prec - 1;
            add_op('prefix', ['-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['lt', 'le', 'gt', 'ge', '<=', '>=', '<', '>'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['<=>', 'cmp', '==', '!=', 'ne', 'eq'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['&'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['|', '^'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['..', '...'], $prec);
            add_op('infix', ['~~'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['&&'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['||'], $prec, {'assoc' => 'right'});
            add_op('infix', ['//'], $prec);
            $prec = $prec - 1;
            add_op('ternary', ['? :'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['=', '**=', '+=', '-=', '*=', '/=', 'x=', '|=', '&=', '.=', '<<=', '>>=', '%=', '||=', '&&=', '^=', '//='], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['=>'], $prec);
            $prec = $prec - 1;
            add_op('list', [','], $prec, {'assoc' => 'list'});
            $prec = $prec - 1;
            add_op('prefix', ['not'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['and'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['or', 'xor'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['*start*'], $prec);
            sub Perlito5::Grammar::Precedence::get_token_precedence {
                my $token = $_[0];
                if ($token->[0] eq 'prefix') {
                    return $PrefixPrecedence->{$token->[1]}
                }
                return $Precedence->{$token->[1]}
            }
            sub Perlito5::Grammar::Precedence::precedence_parse {
                my $self = shift;
                my $get_token = $self->{'get_token'};
                my $reduce = $self->{'reduce'};
                my $last_end_token = $End_token;
                my $last_end_token_chars = $End_token_chars;
                $End_token = $self->{'end_token'};
                $End_token_chars = $self->{'end_token_chars'};
                my $op_stack = [];
                my $num_stack = [];
                my $last = ['op', '*start*'];
                my $last_is_term = 0;
                my $token = $get_token->($last_is_term);
                if ($token->[0] eq 'space') {
                    $token = $get_token->($last_is_term)
                }
                while ((defined($token)) && ($token->[0] ne 'end')) {
                    my $token_is_term = is_term($token);
                    if (($token->[1] eq ',') && (($last->[1] eq '*start*') || ($last->[1] eq ','))) {
                        push(@{$num_stack}, ['term', undef])
                    }
                    if ($Operator->{'prefix'}->{$token->[1]} && (($last->[1] eq '*start*') || !$last_is_term)) {
                        $token->[0] = 'prefix';
                        unshift(@{$op_stack}, $token)
                    }
                    elsif ($Operator->{'postfix'}->{$token->[1]} && $last_is_term) {
                        my $pr = $Precedence->{$token->[1]};
                        while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                            $reduce->($op_stack, $num_stack)
                        }
                        if ($token->[0] ne 'postfix_or_term') {
                            $token->[0] = 'postfix'
                        }
                        unshift(@{$op_stack}, $token);
                        $token_is_term = 1
                    }
                    elsif ($token_is_term) {
                        if ($last_is_term) {
                            print('#      last:  ', Data::Dumper::Dumper($last));
                            print('#      token: ', Data::Dumper::Dumper($token));
                            die('Value tokens must be separated by an operator')
                        }
                        $token->[0] = 'term';
                        push(@{$num_stack}, $token)
                    }
                    elsif ($Precedence->{$token->[1]}) {
                        my $pr = $Precedence->{$token->[1]};
                        if ($Assoc->{'right'}->{$token->[1]}) {
                            while (scalar(@{$op_stack}) && ($pr < get_token_precedence($op_stack->[0]))) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        else {
                            while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        if ($Operator->{'ternary'}->{$token->[1]}) {
                            $token->[0] = 'ternary'
                        }
                        else {
                            $token->[0] = 'infix'
                        }
                        unshift(@{$op_stack}, $token)
                    }
                    else {
                        die('Unknown token: ' . chr(39), $token->[1], chr(39))
                    }
                    $last = $token;
                    $last_is_term = $token_is_term;
                    $token = $get_token->($last_is_term);
                    if ($token->[0] eq 'space') {
                        $token = $get_token->($last_is_term)
                    }
                }
                if (defined($token) && ($token->[0] ne 'end')) {
                    die('Unexpected end token: ', $token)
                }
                while (scalar(@{$op_stack})) {
                    $reduce->($op_stack, $num_stack)
                }
                $End_token = $last_end_token;
                $End_token_chars = $last_end_token_chars;
                return $num_stack
            }
            1
        }
    }
    {
        {
            package main;
            package strict;
            sub strict::import {
                $Perlito5::STRICT = 1
            }
            sub strict::unimport {
                $Perlito5::STRICT = 0
            }
            1
        }
        {
            package main;
            package Perlito5::Grammar::Bareword;
            use strict;
            sub Perlito5::Grammar::Bareword::the_object {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $tmp = $MATCH;
                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::curly_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::curly_parse'});
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Print::typeglob'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Print::typeglob'});
                            1
                        }))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Bareword::term_bareword {
                my $str = $_[0];
                my $pos = $_[1];
                my $p = $pos;
                my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                my $namespace = Perlito5::Match::flat($m_namespace);
                $p = $m_namespace->{'to'};
                my $m_name = Perlito5::Grammar::ident($str, $p);
                if (!$m_name) {
                    if ($namespace) {
                        $m_namespace->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace)];
                        return $m_namespace
                    }
                    return 
                }
                my $name = Perlito5::Match::flat($m_name);
                $p = $m_name->{'to'};
                if (substr($str, $p, 2) eq '::') {
                    $m_name->{'to'} = $p + 2;
                    $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name)];
                    return $m_name
                }
                my $full_name = $name;
                $namespace && ($full_name = $namespace . '::' . $name);
                my $m = Perlito5::Grammar::Space::ws($str, $p);
                if ($m) {
                    $p = $m->{'to'}
                }
                my $invocant;
                my $is_subroutine_name;
                my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
                {
                    my $p = eval {
                        prototype($effective_name)
                    };
                    $p && ($Perlito5::PROTO->{$effective_name} = $p)
                }
                if (exists($Perlito5::Grammar::Print::Print{$name})) {
                    $invocant = undef
                }
                elsif (exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name}))) {
                    $is_subroutine_name = 1;
                    $invocant = Perlito5::Grammar::full_ident($str, $p);
                    my $package = Perlito5::Match::flat($invocant);
                    if ($package) {
                        $invocant->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $package);
                        if (substr($str, $invocant->{'to'}, 2) eq '::') {
                            $invocant->{'to'} = $invocant->{'to'} + 2
                        }
                        elsif (!$Perlito5::PACKAGES->{$package}) {
                            $invocant = undef
                        }
                    }
                }
                else {
                    $invocant = Perlito5::Grammar::Bareword::the_object($str, $p)
                }
                if ($invocant) {
                    $p = $invocant->{'to'};
                    my $arg = [];
                    $m = Perlito5::Grammar::Space::ws($str, $p);
                    $m && ($p = $m->{'to'});
                    if (substr($str, $p, 2) eq '->') {}
                    elsif (substr($str, $p, 1) eq '(') {
                        my $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                        if ($m) {
                            $arg = $m->{'capture'}->[2];
                            $p = $m->{'to'};
                            $arg = Perlito5::Grammar::Expression::expand_list($arg)
                        }
                    }
                    else {
                        my $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                        if ($m->{'capture'} ne '*undef*') {
                            $arg = Perlito5::Grammar::Expression::expand_list($m->{'capture'});
                            $p = $m->{'to'}
                        }
                    }
                    $m_name->{'capture'} = ['term', Perlito5::AST::Call::->new('method' => $full_name, 'invocant' => Perlito5::Match::flat($invocant), 'arguments' => $arg)];
                    $m_name->{'to'} = $p;
                    return $m_name
                }
                if (substr($str, $p, 2) eq '=>') {
                    $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
                    $m_name->{'to'} = $p;
                    return $m_name
                }
                if (substr($str, $p, 2) eq '->') {
                    if ($is_subroutine_name) {
                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [], 'code' => $name, 'namespace' => $namespace)]
                    }
                    else {
                        $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('name' => '', 'namespace' => $full_name, 'sigil' => '::')]
                    }
                    $m_name->{'to'} = $p;
                    return $m_name
                }
                my $sig;
                if (exists($Perlito5::PROTO->{$effective_name})) {
                    $sig = $Perlito5::PROTO->{$effective_name}
                }
                elsif ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                    $effective_name = 'CORE::' . $name;
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                else {
                    my $m = Perlito5::Grammar::Number::val_version($str, $pos);
                    if ($m) {
                        $m->{'capture'} = ['term', $m->{'capture'}];
                        return $m
                    }
                    $sig = undef
                }
                my $has_paren = 0;
                if (defined($sig)) {
                    my $arg_index = 1;
                    my $optional = 0;
                    my @args;
                    my $sig_part = substr($sig, 0, 1);
                    my $m;
                    my $capture;
                    if ($sig_part eq '&') {
                        $m = Perlito5::Grammar::Space::ws($str, $p);
                        $m && ($p = $m->{'to'});
                        if (substr($str, $p, 1) ne '(') {
                            $sig = substr($sig, 1);
                            $m = Perlito5::Grammar::Bareword::prototype_is_ampersand($str, $p);
                            $m && ($capture = $m->{'capture'});
                            if (!$m) {
                                die('Type of arg ' . $arg_index . ' to ' . $name . ' must be block or sub {}')
                            }
                            $p = $m->{'to'};
                            push(@args, $capture)
                        }
                    }
                    if (substr($sig, 0, 1) eq ';' && substr($str, $p, 2) eq '//') {
                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
                        $m_name->{'to'} = $p;
                        return $m_name
                    }
                    if ($sig eq '') {
                        if (substr($str, $p, 1) eq '(') {
                            $p++;
                            $has_paren = 1;
                            my $m = Perlito5::Grammar::Space::ws($str, $p);
                            if ($m) {
                                $p = $m->{'to'}
                            }
                            if (substr($str, $p, 1) ne ')') {
                                die('syntax error near ', substr($str, $pos, 10))
                            }
                            $p++
                        }
                        if ($name eq '__FILE__') {
                            $m_name->{'capture'} = ['term', Perlito5::AST::Buf::->new('buf' => $Perlito5::FILE_NAME)]
                        }
                        elsif ($name eq '__LINE__') {
                            $m_name->{'capture'} = ['term', Perlito5::AST::Int::->new('int' => $Perlito5::LINE_NUMBER)]
                        }
                        else {
                            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0))]
                        }
                        $m_name->{'to'} = $p;
                        return $m_name
                    }
                    if ($sig eq '_' || $sig eq '$' || $sig eq '+' || $sig eq ';$') {
                        my $m;
                        my $arg;
                        if (substr($str, $p, 1) eq '(') {
                            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                            if (!$m) {
                                return $m
                            }
                            $p = $m->{'to'};
                            $has_paren = 1;
                            $arg = $m->{'capture'}->[2];
                            $arg = Perlito5::Grammar::Expression::expand_list($arg);
                            my $v = shift(@{$arg});
                            @{$arg} && die('Too many arguments for ' . $name);
                            $arg = $v
                        }
                        else {
                            $m = Perlito5::Grammar::Expression::argument_parse($str, $p);
                            $arg = $m->{'capture'};
                            if ($arg eq '*undef*') {
                                $arg = undef
                            }
                            elsif (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'circumfix:<( )>') {
                                my $v = shift(@{$arg->{'arguments'}});
                                @{$arg->{'arguments'}} && die('Too many arguments for ' . $name);
                                $arg = $v
                            }
                        }
                        if (defined($arg)) {
                            push(@args, $arg);
                            $has_paren = 1
                        }
                        else {
                            $sig eq '$' && die('Not enough arguments for ' . $name);
                            $sig eq '_' && push(@args, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                        }
                        my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
                        if ($name eq 'eval' && !$namespace) {
                            $ast->{'_scope'} = Perlito5::Grammar::Scope::get_snapshot()
                        }
                        $m->{'capture'} = ['term', $ast];
                        return $m
                    }
                    if ($sig eq ';@') {
                        if (substr($str, $p, 1) eq '(') {
                            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                            $has_paren = 1;
                            my $arg = $m->{'capture'}->[2];
                            $arg = Perlito5::Grammar::Expression::expand_list($arg);
                            push(@args, @{$arg})
                        }
                        else {
                            $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                            my $arg = $m->{'capture'};
                            if ($arg ne '*undef*') {
                                $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                push(@args, @{$arg})
                            }
                        }
                        my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
                        $m->{'capture'} = ['term', $ast];
                        return $m
                    }
                    if ($sig eq '*') {}
                }
                if (substr($str, $p, 1) eq '(') {
                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                    if (!$m) {
                        return $m
                    }
                    my $arg = $m->{'capture'}->[2];
                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                    if ($namespace eq '' || $namespace eq 'CORE') {
                        if ($name eq 'local' || $name eq 'my' || $name eq 'state' || $name eq 'our') {
                            my $declarator = $name;
                            for my $var (@{$arg}) {
                                if (ref($var) eq 'Perlito5::AST::Apply' && $var->{'code'} eq 'undef') {}
                                else {
                                    my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => '', 'var' => $var, 'attributes' => []);
                                    $var->{'_decl'} = $name;
                                    $var->{'_id'} = $Perlito5::ID++;
                                    $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                                    $declarator eq 'local' && !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME)
                                }
                            }
                        }
                        if ($name eq 'print' || $name eq 'say') {
                            if (@{$arg} == 0) {
                                push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                            }
                        }
                        if ($name eq 'split') {
                            if (@{$arg} == 0) {
                                push(@{$arg}, Perlito5::AST::Buf::->new('buf' => ' '))
                            }
                            if (@{$arg} == 1) {
                                push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                            }
                        }
                    }
                    $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => $arg, 'proto' => $sig)];
                    return $m
                }
                my $m_list = Perlito5::Grammar::Expression::list_parse($str, $p);
                my $list = $m_list->{'capture'};
                if ($list ne '*undef*') {
                    $m_name->{'capture'} = ['postfix_or_term', 'funcall', $namespace, $name, $list];
                    $m_name->{'to'} = $m_list->{'to'};
                    return $m_name
                }
                if ($namespace eq '' || $namespace eq 'CORE') {
                    if ($name eq 'print' || $name eq 'say') {
                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
                        return $m_name
                    }
                    if ($name eq 'split' && ($namespace eq '' || $namespace eq 'CORE')) {
                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Buf::->new('buf' => ' '), Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
                        return $m_name
                    }
                }
                $m_name->{'capture'} = ['postfix_or_term', 'funcall_no_params', $namespace, $name];
                return $m_name
            }
            sub Perlito5::Grammar::Bareword::prototype_is_ampersand {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'});
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::Sub::->new('attributes' => [], 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'name' => undef, 'namespace' => undef, 'sig' => undef);
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $tmp = $MATCH;
                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ((chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }) && ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::argument_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::argument_parse'});
                            1
                        }))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            1
        }
    }
    {
        {
            package main;
            undef();
            package Perlito5::Grammar::Attribute;
            sub Perlito5::Grammar::Attribute::opt_attribute {
                my $str = $_[0];
                my $pos = $_[1];
                my @attributes;
                my $ws = Perlito5::Grammar::Space::opt_ws($str, $pos);
                if (substr($str, $ws->{'to'}, 1) ne ':') {
                    return {'to' => $pos, 'capture' => []}
                }
                $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1);
                my $p = $ws->{'to'};
                my $m = Perlito5::Grammar::ident($str, $p);
                !$m && die('syntax error');
                my $to;
                while (1) {
                    my $attr = [Perlito5::Match::flat($m), undef];
                    $to = $m->{'to'};
                    my $delimiter = substr($str, $to, 1);
                    if ($delimiter eq '(') {
                        my $params = Perlito5::Grammar::String::string_interpolation_parse($str, $m->{'to'} + 1, '(', ')', 0);
                        !$params && die('syntax error');
                        $attr->[1] = Perlito5::Match::flat($params)->{'buf'};
                        $to = $params->{'to'}
                    }
                    push(@attributes, $attr);
                    $ws = Perlito5::Grammar::Space::opt_ws($str, $to);
                    if (substr($str, $ws->{'to'}, 1) eq ':') {
                        $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1)
                    }
                    $p = $ws->{'to'};
                    $m = Perlito5::Grammar::ident($str, $p);
                    !$m && return {'to' => $to, 'capture' => \@attributes}
                }
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Grammar::Statement;
            {
                {
                    package main;
                    undef();
                    package Perlito5::Macro;
                    use strict;
                    {
                        package Perlito5::AST::Apply;
                        use strict;
                        my %op = ('infix:<+=>' => 'infix:<+>', 'infix:<-=>' => 'infix:<->', 'infix:<*=>' => 'infix:<*>', 'infix:</=>' => 'infix:</>', 'infix:<||=>' => 'infix:<||>', 'infix:<&&=>' => 'infix:<&&>', 'infix:<|=>' => 'infix:<|>', 'infix:<&=>' => 'infix:<&>', 'infix:<//=>' => 'infix:<//>', 'infix:<.=>' => 'list:<.>', 'infix:<x=>' => 'infix:<x>');
                        sub Perlito5::AST::Apply::op_assign {
                            my $self = $_[0];
                            my $code = $self->{'code'};
                            ref($code) && return 0;
                            if (exists($op{$code})) {
                                return Perlito5::AST::Apply::->new('code' => 'infix:<=>', 'arguments' => [$self->{'arguments'}->[0], Perlito5::AST::Apply::->new('code' => $op{$code}, 'arguments' => $self->{'arguments'})])
                            }
                            return 0
                        }
                        my %op_auto = ('prefix:<++>' => 1, 'prefix:<-->' => 1, 'postfix:<++>' => 1, 'postfix:<-->' => 1);
                        sub Perlito5::AST::Apply::op_auto {
                            my $self = $_[0];
                            my $code = $self->{'code'};
                            ref($code) && return 0;
                            if (exists($op_auto{$code})) {
                                my $paren = $self->{'arguments'}->[0];
                                if ($paren->{'code'} eq 'circumfix:<( )>') {
                                    my $arg = $paren->{'arguments'}->[-1];
                                    if ($arg->{'code'} eq 'infix:<=>') {
                                        my $var = $arg->{'arguments'}->[0];
                                        return Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::AST::Block::->new('stmts' => [$paren, Perlito5::AST::Apply::->new('code' => $code, 'arguments' => [$var])])])
                                    }
                                }
                            }
                            return 0
                        }
                    }
                    sub Perlito5::Macro::while_file {
                        my $self = $_[0];
                        ref($self) ne 'Perlito5::AST::While' && return 0;
                        my $cond = $self->{'cond'};
                        if ($cond->isa('Perlito5::AST::Apply') && ($cond->{'code'} eq 'readline')) {
                            $self->{'cond'} = bless({'arguments' => [bless({'arguments' => [Perlito5::AST::Var::->new('name' => '_', 'namespace' => '', 'sigil' => '$'), $cond], 'code' => 'infix:<=>', 'namespace' => ''}, 'Perlito5::AST::Apply')], 'bareword' => '', 'code' => 'defined', 'namespace' => ''}, 'Perlito5::AST::Apply');
                            return $self
                        }
                        return 0
                    }
                }
            }
            my @Statement_chars;
            my %Statement;
            sub Perlito5::Grammar::Statement::add_statement {
                my $name = shift;
                my $param = shift;
                $Statement{$name} = $param;
                unshift(@Statement_chars, scalar(@Statement_chars) + 1)
                    while @Statement_chars < length($name)
            }
            sub Perlito5::Grammar::Statement::stmt_yadayada {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((('...' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'die', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => 'Unimplemented')]);
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Statement::stmt_format {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((('format' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (do {
                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'Perlito5::Grammar::full_ident'} = 'STDOUT';
                            1
                        })
                    })
                }) && (do {
                    $MATCH->{'str'} = $str;
                    my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
                    push(@Perlito5::Grammar::String::Here_doc, ['single_quote', $placeholder->{'arguments'}->[0]->{'arguments'}, '.']);
                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:format', 'namespace' => '', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), $placeholder]);
                    1
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && ('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Statement::stmt_package {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((('package' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                            $MATCH->{'_package'} = $Perlito5::PKG_NAME;
                            $Perlito5::PACKAGES->{$name} = 1;
                            $Perlito5::PKG_NAME = $name;
                            1
                        }) && (do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})), @{$MATCH->{'Perlito5::Grammar::block'}->{'capture'}->{'stmts'}}]);
                            $Perlito5::PKG_NAME = $MATCH->{'_package'};
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                            $Perlito5::PACKAGES->{$name} = 1;
                            $Perlito5::PKG_NAME = $name;
                            $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => $name);
                            1
                        })
                    })
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::Statement::exp_stmt {
                my $str = $_[0];
                my $pos = $_[1];
                for my $len (@Statement_chars) {
                    my $term = substr($str, $pos, $len);
                    if (exists($Statement{$term})) {
                        my $m = $Statement{$term}->($str, $pos);
                        $m && return $m
                    }
                }
                return 0
            }
            my @Modifier_chars = (7, 6, 5, 4, 3, 2);
            my %Modifier = ('if' => 1, 'unless' => 1, 'when' => 1, 'for' => 1, 'foreach' => 1, 'while' => 1, 'until' => 1, 'given' => 1);
            sub Perlito5::Grammar::Statement::statement_modifier {
                my $str = $_[0];
                my $pos = $_[1];
                my $expression = $_[2];
                for my $len (@Modifier_chars) {
                    my $term = substr($str, $pos, $len);
                    if (exists($Modifier{$term})) {
                        my $m = modifier($str, $pos + $len, $term, $expression);
                        $m && return $m
                    }
                }
                return 0
            }
            sub Perlito5::Grammar::Statement::modifier {
                my $str = $_[0];
                my $pos = $_[1];
                my $modifier = $_[2];
                my $expression = $_[3];
                my $modifier_exp = Perlito5::Grammar::Expression::exp_parse($str, $pos);
                if (!$modifier_exp) {
                    die('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
                }
                if ($modifier eq 'if') {
                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<&&>', 'namespace' => '')}
                }
                if ($modifier eq 'unless') {
                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<||>', 'namespace' => '')}
                }
                if ($modifier eq 'when') {
                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression)}
                }
                if ($modifier eq 'while') {
                    my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression);
                    my $out = Perlito5::Macro::while_file($stmt);
                    $out && ($stmt = $out);
                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
                }
                if ($modifier eq 'until') {
                    my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp)], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => $expression);
                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
                }
                if ($modifier eq 'for' || $modifier eq 'foreach') {
                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression, 'topic' => Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))}
                }
                die('Unexpected statement modifier ' . chr(39) . $modifier . chr(39))
            }
            sub Perlito5::Grammar::Statement::statement_parse {
                my $m = statement_parse_inner(@_);
                !@Perlito5::SCOPE_STMT && return $m;
                Perlito5::Grammar::Scope::check_variable_declarations();
                return $m
            }
            sub Perlito5::Grammar::Statement::statement_parse_inner {
                my $str = $_[0];
                my $pos = $_[1];
                my $res = exp_stmt($str, $pos);
                if ($res) {
                    return $res
                }
                $res = Perlito5::Grammar::Expression::exp_parse($str, $pos);
                if (!$res) {
                    return 
                }
                if (substr($str, $res->{'to'}, 1) eq ':' && $res->{'capture'}->isa('Perlito5::AST::Apply') && $res->{'capture'}->{'bareword'}) {
                    my $label = $res->{'capture'}->{'code'};
                    my $ws = Perlito5::Grammar::Space::opt_ws($str, $res->{'to'} + 1);
                    my $stmt = statement_parse($str, $ws->{'to'});
                    if ($stmt) {
                        $stmt->{'capture'}->{'label'} = $label;
                        return $stmt
                    }
                    $res->{'to'} = $ws->{'to'};
                    $res->{'capture'} = Perlito5::AST::Apply::->new('arguments' => [], 'code' => 'undef', 'namespace' => '', 'label' => $label);
                    return $res
                }
                my $modifier = statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res));
                my $p = $modifier ? $modifier->{'to'} : $res->{'to'};
                my $terminator = substr($str, $p, 1);
                $terminator ne ';' && $terminator ne '}' && $terminator ne '' && die('Number or Bareword found where operator expected');
                if (!$modifier) {
                    return $res
                }
                return $modifier
            }
            Perlito5::Grammar::Statement::add_statement('...' => \&stmt_yadayada);
            Perlito5::Grammar::Statement::add_statement('package' => \&stmt_package);
            Perlito5::Grammar::Statement::add_statement('format' => \&stmt_format);
            1
        }
    }
    sub Perlito5::Grammar::Expression::expand_list {
        my $param_list = shift;
        if (ref($param_list) eq 'Perlito5::AST::Apply' && $param_list->code() eq 'list:<,>') {
            return [grep {
                defined($_)
            } @{$param_list->arguments()}]
        }
        elsif ($param_list eq '*undef*') {
            return []
        }
        else {
            return [$param_list]
        }
    }
    sub Perlito5::Grammar::Expression::block_or_hash {
        my $o = shift;
        if (defined($o->sig())) {
            return $o
        }
        my $stmts = $o->stmts();
        if (!(defined($stmts)) || scalar(@{$stmts}) == 0) {
            return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [])
        }
        if (scalar(@{$stmts}) != 1) {
            return $o
        }
        my $stmt = $stmts->[0];
        if (ref($stmt) eq 'Perlito5::AST::Var') {
            return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
        }
        if (ref($stmt) ne 'Perlito5::AST::Apply') {
            return $o
        }
        if ($stmt->code() eq 'infix:<=>>' || $stmt->code() eq 'prefix:<%>' || $stmt->code() eq 'prefix:<@>') {
            return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
        }
        if ($stmt->code() ne 'list:<,>') {
            return $o
        }
        return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => expand_list($stmt))
    }
    sub Perlito5::Grammar::Expression::pop_term {
        my $num_stack = shift;
        my $v = pop(@{$num_stack});
        if (ref($v) eq 'ARRAY') {
            ref($v->[1]) && return $v->[1];
            if ($v->[1] eq 'methcall_no_params') {
                $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => []);
                return $v
            }
            if ($v->[1] eq 'funcall_no_params') {
                $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'namespace' => $v->[2], 'arguments' => [], 'bareword' => 1);
                return $v
            }
            if ($v->[1] eq 'methcall') {
                my $param_list = expand_list(($v->[3]));
                $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => $param_list);
                return $v
            }
            if ($v->[1] eq 'funcall') {
                my $param_list = expand_list(($v->[4]));
                $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'arguments' => $param_list, 'namespace' => $v->[2]);
                return $v
            }
            if ($v->[1] eq '( )') {
                my $param_list = expand_list($v->[2]);
                $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<( )>', 'arguments' => $param_list, 'namespace' => '');
                return $v
            }
            if ($v->[1] eq '[ ]') {
                my $param_list = expand_list($v->[2]);
                $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<[ ]>', 'arguments' => $param_list, 'namespace' => '');
                return $v
            }
            if ($v->[1] eq 'block') {
                $v = Perlito5::AST::Block::->new('stmts' => $v->[2], 'sig' => $v->[3]);
                $v = block_or_hash($v);
                return $v
            }
            if ($v->[1] eq '.( )') {
                $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => 'postcircumfix:<( )>', 'arguments' => $v->[2]);
                return $v
            }
            if ($v->[1] eq '.[ ]') {
                $v = Perlito5::AST::Index::->new('obj' => undef, 'index_exp' => $v->[2]);
                return $v
            }
            if ($v->[1] eq '.{ }') {
                $v = Perlito5::AST::Lookup::->new('obj' => undef, 'index_exp' => $v->[2]);
                return $v
            }
            return $v->[1]
        }
        return $v
    }
    sub Perlito5::Grammar::Expression::reduce_postfix {
        my $op = shift;
        my $value = shift;
        my $v = $op;
        if ($v->[1] eq 'methcall_no_params') {
            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => []);
            return $v
        }
        if ($v->[1] eq 'funcall_no_params') {
            die('Bareword found where operator expected')
        }
        if ($v->[1] eq 'methcall') {
            my $param_list = expand_list($v->[3]);
            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => $param_list);
            return $v
        }
        if ($v->[1] eq 'funcall') {
            die('unexpected function call')
        }
        if ($v->[1] eq '( )') {
            my $param_list = expand_list($v->[2]);
            if (ref($value) eq 'Perlito5::AST::Apply' && !(defined($value->arguments()))) {
                $value->{'arguments'} = $param_list;
                return $value
            }
            if (ref($value) eq 'Perlito5::AST::Call' && !(defined($value->arguments()))) {
                $value->{'arguments'} = $param_list;
                return $value
            }
            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
            return $v
        }
        if ($v->[1] eq '[ ]') {
            if (ref($value) eq 'Perlito5::AST::Var') {
                $value->{'_real_sigil'} = '@'
            }
            $v = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $v->[2]);
            return $v
        }
        if ($v->[1] eq 'block') {
            if (ref($value) eq 'Perlito5::AST::Var') {
                $value->{'_real_sigil'} = '%'
            }
            $v = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => $v->[2]->[0]);
            return $v
        }
        if ($v->[1] eq '.( )') {
            my $param_list = expand_list($v->[2]);
            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
            return $v
        }
        if ($v->[1] eq '.[ ]') {
            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<[ ]>', 'arguments' => $v->[2]);
            return $v
        }
        if ($v->[1] eq '.{ }') {
            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<{ }>', 'arguments' => $v->[2]);
            return $v
        }
        push(@{$op}, $value);
        return $op
    }
    my $reduce_to_ast = sub {
        my $op_stack = shift;
        my $num_stack = shift;
        my $last_op = shift(@{$op_stack});
        if ($last_op->[0] eq 'prefix') {
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'prefix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
        }
        elsif ($last_op->[0] eq 'postfix') {
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'postfix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
        }
        elsif ($last_op->[0] eq 'postfix_or_term') {
            push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)))
        }
        elsif (Perlito5::Grammar::Precedence::is_assoc_type('list', $last_op->[1])) {
            my $arg;
            if (scalar(@{$num_stack}) < 2) {
                my $v2 = pop_term($num_stack);
                if (ref($v2) eq 'Perlito5::AST::Apply' && $v2->code() eq ('list:<' . $last_op->[1] . '>')) {
                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => $v2->namespace(), 'code' => $v2->code(), 'arguments' => [@{$v2->arguments()}]))
                }
                else {
                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => [$v2]))
                }
                return 
            }
            else {
                my $v2 = pop_term($num_stack);
                $arg = [pop_term($num_stack), $v2]
            }
            if (ref($arg->[0]) eq 'Perlito5::AST::Apply' && $last_op->[0] eq 'infix' && ($arg->[0]->code() eq 'list:<' . $last_op->[1] . '>')) {
                push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => ($arg->[0])->code(), 'arguments' => [@{($arg->[0])->arguments()}, $arg->[1]]));
                return 
            }
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => $arg))
        }
        elsif (Perlito5::Grammar::Precedence::is_assoc_type('chain', $last_op->[1])) {
            if (scalar(@{$num_stack}) < 2) {
                die('Missing value after operator ' . $last_op->[1])
            }
            my $v2 = pop_term($num_stack);
            my $arg = [pop_term($num_stack), $v2];
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => $arg))
        }
        elsif ($last_op->[0] eq 'ternary') {
            if (scalar(@{$num_stack}) < 2) {
                die('Missing value after ternary operator')
            }
            my $v2 = pop_term($num_stack);
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ternary:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $last_op->[2], $v2]))
        }
        else {
            if (scalar(@{$num_stack}) < 2) {
                die('missing value after operator ' . chr(39) . $last_op->[1] . chr(39))
            }
            my $v2 = pop_term($num_stack);
            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $v2]))
        }
    };
    sub Perlito5::Grammar::Expression::term_arrow {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('->' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = paren_parse($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'paren_parse'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = square_parse($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'square_parse'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = curly_parse($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'curly_parse'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            die('Missing right curly or square bracket');
                            1
                        })
                    })
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'})), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}))];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})];
                            1
                        })
                    })
                }))
            })
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_ternary {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = ternary5_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'ternary5_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = paren_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'paren_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_square {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = square_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'square_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_curly {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m = $MATCH;
            if (!(do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {
                    0
                }
            })) {
                $MATCH = $m
            }
            1
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    })) {
                        $MATCH = $m
                    }
                    1
                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = ['postfix_or_term', 'block', [Perlito5::AST::Apply::->new('arguments' => [], 'bareword' => 1, 'code' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), 'namespace' => '')]];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'_save_scope'} = [@Perlito5::SCOPE_STMT];
                    @Perlito5::SCOPE_STMT = ();
                    1
                }) && (do {
                    my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::exp_stmts'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    @Perlito5::SCOPE_STMT = @{$MATCH->{'_save_scope'}};
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    })) {
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            $MATCH->{'str'} = $str;
                            die('Missing right curly or square bracket');
                            1
                        })
                    })
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::exp_stmts'})];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::declarator {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('my' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('state' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('our' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_declarator {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = declarator($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'declarator'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = Perlito5::Grammar::Block::named_sub($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Block::named_sub'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $sub = $MATCH->{'Perlito5::Grammar::Block::named_sub'}->{'capture'};
                            $sub->{'decl'} = Perlito5::Match::flat($MATCH->{'declarator'});
                            $MATCH->{'capture'} = ['term', $sub];
                            return $MATCH;
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            my $m2 = Perlito5::Grammar::opt_type($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::opt_type'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                1
            })
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'Perlito5::Grammar::var_ident'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            my $declarator = Perlito5::Match::flat($MATCH->{'declarator'});
            my $type = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::opt_type'});
            $type && !$Perlito5::PACKAGES->{$type} && die('No such class ' . $type);
            my $var = $MATCH->{'Perlito5::Grammar::var_ident'}->{'capture'};
            $var->{'namespace'} && die('No package name allowed for variable ' . $var->{'sigil'} . $var->{'name'} . ' in "' . $declarator . '"');
            $var->{'_decl'} = $declarator;
            $var->{'_id'} = $Perlito5::ID++;
            $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
            my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var, 'attributes' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'}));
            $MATCH->{'capture'} = ['term', $decl];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_not {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('not' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = paren_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'paren_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'prefix:<not>', 'arguments' => expand_list(Perlito5::Match::flat($MATCH->{'paren_parse'})), 'namespace' => '')];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_local {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('local' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            my $declarator = 'local';
            my $type = '';
            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
            $MATCH = Perlito5::Grammar::String::double_quoted_var_with_subscript($MATCH);
            my $var = $MATCH->{'capture'};
            my $look = Perlito5::Grammar::Scope::lookup_variable($var);
            if ($look && ($look->{'_decl'} eq 'my' || $look->{'_decl'} eq 'state')) {
                die('Can' . chr(39) . 't localize lexical variable ' . $var->{'sigil'} . $var->{'name'})
            }
            $var->{'_id'} = $Perlito5::ID++;
            $var->{'_decl'} = $declarator;
            !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
            my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var);
            $MATCH->{'capture'} = ['term', $decl];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_return {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('return' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $m2 = list_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'list_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            my $args = Perlito5::Match::flat($MATCH->{'list_parse'});
            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'return', 'arguments' => $args eq '*undef*' ? [] : [$args], 'namespace' => '')];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Expression::term_eval {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('eval' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})], 'namespace' => '')];
            1
        })));
        $tmp ? $MATCH : 0
    }
    my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
    my $Expr_end_token = {']' => 1, ')' => 1, '}' => 1, ';' => 1, 'if' => 1, 'for' => 1, 'else' => 1, 'when' => 1, 'while' => 1, 'until' => 1, 'elsif' => 1, 'unless' => 1, 'foreach' => 1};
    my $List_end_token = {':' => 1, 'or' => 1, 'and' => 1, 'xor' => 1, %{$Expr_end_token}};
    my $Argument_end_token = {',' => 1, '<' => 1, '>' => 1, '=' => 1, '|' => 1, '^' => 1, '?' => 1, '=>' => 1, 'lt' => 1, 'le' => 1, 'gt' => 1, 'ge' => 1, '<=' => 1, '>=' => 1, '==' => 1, '!=' => 1, 'ne' => 1, 'eq' => 1, '..' => 1, '~~' => 1, '&&' => 1, '||' => 1, '+=' => 1, '-=' => 1, '*=' => 1, '/=' => 1, 'x=' => 1, '|=' => 1, '&=' => 1, '.=' => 1, '^=' => 1, '%=' => 1, '//' => 1, '...' => 1, '<=>' => 1, 'cmp' => 1, '<<=' => 1, '>>=' => 1, '||=' => 1, '&&=' => 1, '//=' => 1, '**=' => 1, %{$List_end_token}};
    sub Perlito5::Grammar::Expression::list_parser {
        my($str, $pos, $end_token) = @_;
        my $expr;
        my $last_pos = $pos;
        my $is_first_token = 1;
        my $lexer_stack = [];
        my $last_token_was_space = 1;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {
                $v = pop(@{$lexer_stack});
                if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                    $v->[0] = 'end'
                }
            }
            else {
                my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                    if ($spc) {
                        $m->{'to'} = $spc->{'to'}
                    }
                }
                if (!$m) {
                    return ['end', '*end*']
                }
                $v = $m->{'capture'};
                if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                    $v->[0] = 'end'
                }
                if ($v->[0] ne 'end') {
                    $last_pos = $m->{'to'}
                }
            }
            $last_token_was_space = ($v->[0] eq 'space');
            $is_first_token = 0;
            return $v
        };
        my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $end_token, 'end_token_chars' => $Expr_end_token_chars);
        my $res = $prec->precedence_parse();
        if (scalar(@{$res}) == 0) {
            return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => '*undef*'}
        }
        my $result = pop_term($res);
        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
    }
    sub Perlito5::Grammar::Expression::argument_parse {
        my($str, $pos) = @_;
        return list_parser($str, $pos, $Argument_end_token)
    }
    sub Perlito5::Grammar::Expression::list_parse {
        my($str, $pos) = @_;
        return list_parser($str, $pos, $List_end_token)
    }
    sub Perlito5::Grammar::Expression::circumfix_parse {
        my($str, $pos, $delimiter) = @_;
        my $expr;
        my $last_pos = $pos;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if ($m) {
                my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                if ($spc) {
                    $m->{'to'} = $spc->{'to'}
                }
            }
            if (!$m) {
                my $msg = 'Expected closing delimiter: ' . $delimiter;
                ($delimiter eq '}' || $delimiter eq ']') && ($msg = 'Missing right curly or square bracket');
                die($msg . ' near ', $last_pos)
            }
            my $v = $m->{'capture'};
            if ($v->[0] ne 'end') {
                $last_pos = $m->{'to'}
            }
            return $v
        };
        my %delim_token;
        $delim_token{$delimiter} = 1;
        my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => \%delim_token, 'end_token_chars' => [length($delimiter)]);
        my $res = $prec->precedence_parse();
        $res = pop_term($res);
        if (!(defined($res))) {
            $res = '*undef*'
        }
        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $res}
    }
    sub Perlito5::Grammar::Expression::ternary5_parse {
        return circumfix_parse(@_, ':')
    }
    sub Perlito5::Grammar::Expression::curly_parse {
        return circumfix_parse(@_, '}')
    }
    sub Perlito5::Grammar::Expression::square_parse {
        return circumfix_parse(@_, ']')
    }
    sub Perlito5::Grammar::Expression::paren_parse {
        return circumfix_parse(@_, ')')
    }
    sub Perlito5::Grammar::Expression::exp_parse {
        my($str, $pos) = @_;
        my $expr;
        my $last_pos = $pos;
        my $lexer_stack = [];
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {
                $v = pop(@{$lexer_stack})
            }
            else {
                my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                    if ($spc) {
                        $m->{'to'} = $spc->{'to'}
                    }
                }
                if (!$m) {
                    return ['end', '*end*']
                }
                $v = $m->{'capture'};
                if ($v->[0] ne 'end') {
                    $last_pos = $m->{'to'}
                }
            }
            return $v
        };
        my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $Expr_end_token, 'end_token_chars' => $Expr_end_token_chars);
        my $res = $prec->precedence_parse();
        if (scalar(@{$res}) == 0) {
            return 0
        }
        my $result = pop_term($res);
        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
    }
    Perlito5::Grammar::Precedence::add_term('my' => \&term_declarator);
    Perlito5::Grammar::Precedence::add_term('our' => \&term_declarator);
    Perlito5::Grammar::Precedence::add_term('eval' => \&term_eval);
    Perlito5::Grammar::Precedence::add_term('state' => \&term_declarator);
    Perlito5::Grammar::Precedence::add_term('local' => \&term_local);
    Perlito5::Grammar::Precedence::add_term('return' => \&term_return);
    Perlito5::Grammar::Precedence::add_term('not' => \&term_not);
    1
}
;1
