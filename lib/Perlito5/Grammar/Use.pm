# Do not edit this file - Generated by Perlito5 9.009
{
    package main;
    package Perlito5::Grammar::Use;
    {
        {
            package main;
            package Perlito5::Grammar::Precedence;
            {
                {
                    package main;
                    package feature;
                    sub feature::import {}
                    sub feature::unimport {}
                    1
                }
            }
            sub Perlito5::Grammar::Precedence::new {
                my $class = shift;
                bless({@_}, $class)
            }
            my $Operator = {};
            my $Precedence = {};
            my $PrefixPrecedence = {};
            my $Assoc = {};
            sub Perlito5::Grammar::Precedence::is_assoc_type {
                my $assoc_type = shift;
                my $op_name = shift;
                return $Assoc->{$assoc_type}->{$op_name}
            }
            sub Perlito5::Grammar::Precedence::is_fixity_type {
                my $fixity_type = shift;
                my $op_name = shift;
                return $Operator->{$fixity_type}->{$op_name}
            }
            sub Perlito5::Grammar::Precedence::is_term {
                my $token = shift;
                ($token->[0] eq 'term') || ($token->[0] eq 'postfix_or_term') || ($token->[0] eq 'postfix')
            }
            sub Perlito5::Grammar::Precedence::is_num {
                $_[0] ge 0 && $_[0] le 9
            }
            sub Perlito5::Grammar::Precedence::is_ident_middle {
                my $c = shift;
                ($c ge 'a' && $c le 'z') || ($c ge 0 && $c le 9) || ($c eq '_')
            }
            my @Parsed_op_chars = (2, 1);
            my %Parsed_op = ('?' => sub {
                Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
            }, '(' => sub {
                Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
            }, '[' => sub {
                Perlito5::Grammar::Expression::term_square($_[0], $_[1])
            }, '{' => sub {
                Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
            }, '->' => sub {
                Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
            });
            my @Term_chars;
            my %Term;
            sub Perlito5::Grammar::Precedence::add_term {
                my $name = shift;
                my $param = shift;
                $Term{$name} = $param;
                unshift(@Term_chars, scalar(@Term_chars) + 1)
                    while @Term_chars < length($name)
            }
            my $End_token;
            my $End_token_chars;
            my %Op;
            my @Op_chars = (3, 2, 1);
            sub Perlito5::Grammar::Precedence::op_parse {
                my $str = shift;
                my $pos = shift;
                my $last_is_term = shift;
                for my $len (@{$End_token_chars}) {
                    my $term = substr($str, $pos, $len);
                    if (exists($End_token->{$term})) {
                        my $c1 = substr($str, $pos + $len - 1, 1);
                        my $c2 = substr($str, $pos + $len, 1);
                        if (!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '<' && $c2 eq '<')) {
                            return {'str' => $str, 'from' => $pos, 'to' => $pos, 'capture' => ['end', $term]}
                        }
                    }
                }
                if (!$last_is_term) {
                    for my $len (@Term_chars) {
                        my $term = substr($str, $pos, $len);
                        if (exists($Term{$term})) {
                            my $c1 = substr($str, $pos + $len - 1, 1);
                            my $c2 = substr($str, $pos + $len, 1);
                            if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                                my $m = $Term{$term}->($str, $pos);
                                $m && return $m
                            }
                        }
                    }
                }
                for my $len (@Parsed_op_chars) {
                    my $op = substr($str, $pos, $len);
                    if (exists($Parsed_op{$op})) {
                        my $m = $Parsed_op{$op}->($str, $pos);
                        $m && return $m
                    }
                }
                for my $len (@Op_chars) {
                    my $op = substr($str, $pos, $len);
                    if (exists($Op{$op})) {
                        my $c1 = substr($str, $pos + $len - 1, 1);
                        my $c2 = substr($str, $pos + $len, 1);
                        if ((!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '&' && $c2 eq '&')) || ($c1 eq 'x' && $c2 ge 0 && $c2 le 9)) {
                            if (exists($Operator->{'infix'}->{$op}) && !exists($Operator->{'prefix'}->{$op}) && !$last_is_term) {}
                            else {
                                return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['op', $op]}
                            }
                        }
                    }
                }
                return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
            }
            sub Perlito5::Grammar::Precedence::add_op {
                my($fixity, $names, $precedence, $param) = @_;
                $param //= {};
                my $assoc = $param->{'assoc'} || 'left';
                for my $name (@{$names}) {
                    $Operator->{$fixity}->{$name} = 1;
                    $Precedence->{$name} = $precedence;
                    $fixity eq 'prefix' && ($PrefixPrecedence->{$name} = $precedence);
                    $Assoc->{$assoc}->{$name} = 1;
                    $Op{$name} = 1
                }
            }
            my $prec = 100;
            add_op('postfix', ['.( )', '.[ ]', '.{ }', '( )', '[ ]', 'funcall', 'funcall_no_params', 'methcall', 'methcall_no_params', 'block', 'hash'], $prec);
            $prec = $prec - 1;
            add_op('prefix', ['++', '--'], $prec);
            add_op('postfix', ['++', '--'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['**'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('prefix', [chr(92), '+', '-', '~', '!'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['=~', '!~'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['*', '/', '%', 'x'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['+', '-'], $prec);
            add_op('infix', ['.'], $prec, {'assoc' => 'list'});
            $prec = $prec - 1;
            add_op('infix', ['<<', '>>'], $prec);
            $prec = $prec - 1;
            add_op('prefix', ['-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['lt', 'le', 'gt', 'ge', '<=', '>=', '<', '>'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['<=>', 'cmp', '==', '!=', 'ne', 'eq'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['&'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['|', '^'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['..', '...'], $prec);
            add_op('infix', ['~~'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['&&'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['||'], $prec, {'assoc' => 'right'});
            add_op('infix', ['//'], $prec);
            $prec = $prec - 1;
            add_op('ternary', ['? :'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['=', '**=', '+=', '-=', '*=', '/=', 'x=', '|=', '&=', '.=', '<<=', '>>=', '%=', '||=', '&&=', '^=', '//='], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['=>'], $prec);
            $prec = $prec - 1;
            add_op('list', [','], $prec, {'assoc' => 'list'});
            $prec = $prec - 1;
            add_op('prefix', ['not'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['and'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['or', 'xor'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['*start*'], $prec);
            sub Perlito5::Grammar::Precedence::get_token_precedence {
                my $token = $_[0];
                if ($token->[0] eq 'prefix') {
                    return $PrefixPrecedence->{$token->[1]}
                }
                return $Precedence->{$token->[1]}
            }
            sub Perlito5::Grammar::Precedence::precedence_parse {
                my $self = shift;
                my $get_token = $self->{'get_token'};
                my $reduce = $self->{'reduce'};
                my $last_end_token = $End_token;
                my $last_end_token_chars = $End_token_chars;
                $End_token = $self->{'end_token'};
                $End_token_chars = $self->{'end_token_chars'};
                my $op_stack = [];
                my $num_stack = [];
                my $last = ['op', '*start*'];
                my $last_is_term = 0;
                my $token = $get_token->($last_is_term);
                if ($token->[0] eq 'space') {
                    $token = $get_token->($last_is_term)
                }
                while ((defined($token)) && ($token->[0] ne 'end')) {
                    my $token_is_term = is_term($token);
                    if (($token->[1] eq ',') && (($last->[1] eq '*start*') || ($last->[1] eq ','))) {
                        push(@{$num_stack}, ['term', undef])
                    }
                    if ($Operator->{'prefix'}->{$token->[1]} && (($last->[1] eq '*start*') || !$last_is_term)) {
                        $token->[0] = 'prefix';
                        unshift(@{$op_stack}, $token)
                    }
                    elsif ($Operator->{'postfix'}->{$token->[1]} && $last_is_term) {
                        my $pr = $Precedence->{$token->[1]};
                        while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                            $reduce->($op_stack, $num_stack)
                        }
                        if ($token->[0] ne 'postfix_or_term') {
                            $token->[0] = 'postfix'
                        }
                        unshift(@{$op_stack}, $token);
                        $token_is_term = 1
                    }
                    elsif ($token_is_term) {
                        if ($last_is_term) {
                            print('#      last:  ', Data::Dumper::Dumper($last));
                            print('#      token: ', Data::Dumper::Dumper($token));
                            die('Value tokens must be separated by an operator')
                        }
                        $token->[0] = 'term';
                        push(@{$num_stack}, $token)
                    }
                    elsif ($Precedence->{$token->[1]}) {
                        my $pr = $Precedence->{$token->[1]};
                        if ($Assoc->{'right'}->{$token->[1]}) {
                            while (scalar(@{$op_stack}) && ($pr < get_token_precedence($op_stack->[0]))) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        else {
                            while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        if ($Operator->{'ternary'}->{$token->[1]}) {
                            $token->[0] = 'ternary'
                        }
                        else {
                            $token->[0] = 'infix'
                        }
                        unshift(@{$op_stack}, $token)
                    }
                    else {
                        die('Unknown token: ' . chr(39), $token->[1], chr(39))
                    }
                    $last = $token;
                    $last_is_term = $token_is_term;
                    $token = $get_token->($last_is_term);
                    if ($token->[0] eq 'space') {
                        $token = $get_token->($last_is_term)
                    }
                }
                if (defined($token) && ($token->[0] ne 'end')) {
                    die('Unexpected end token: ', $token)
                }
                while (scalar(@{$op_stack})) {
                    $reduce->($op_stack, $num_stack)
                }
                $End_token = $last_end_token;
                $End_token_chars = $last_end_token_chars;
                return $num_stack
            }
            1
        }
    }
    {
        {
            package main;
            package Perlito5::Grammar;
            {
                {
                    package main;
                    package Perlito5::Grammar::Expression;
                    undef();
                    {
                        {
                            package main;
                            package strict;
                            sub strict::import {
                                $Perlito5::STRICT = 1
                            }
                            sub strict::unimport {
                                $Perlito5::STRICT = 0
                            }
                            1
                        }
                        {
                            package main;
                            package Perlito5::Grammar::Bareword;
                            use strict;
                            sub Perlito5::Grammar::Bareword::the_object {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::curly_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::curly_parse'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Print::typeglob'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Print::typeglob'});
                                            1
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Bareword::term_bareword {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $p = $pos;
                                my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                                my $namespace = Perlito5::Match::flat($m_namespace);
                                $p = $m_namespace->{'to'};
                                my $m_name = Perlito5::Grammar::ident($str, $p);
                                if (!$m_name) {
                                    if ($namespace) {
                                        $m_namespace->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace)];
                                        return $m_namespace
                                    }
                                    return 
                                }
                                my $name = Perlito5::Match::flat($m_name);
                                $p = $m_name->{'to'};
                                if (substr($str, $p, 2) eq '::') {
                                    $m_name->{'to'} = $p + 2;
                                    $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name)];
                                    return $m_name
                                }
                                my $full_name = $name;
                                $namespace && ($full_name = $namespace . '::' . $name);
                                my $m = Perlito5::Grammar::Space::ws($str, $p);
                                if ($m) {
                                    $p = $m->{'to'}
                                }
                                my $invocant;
                                my $is_subroutine_name;
                                my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
                                {
                                    my $p = eval {
                                        prototype($effective_name)
                                    };
                                    $p && ($Perlito5::PROTO->{$effective_name} = $p)
                                }
                                if (exists($Perlito5::Grammar::Print::Print{$name})) {
                                    $invocant = undef
                                }
                                elsif (exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name}))) {
                                    $is_subroutine_name = 1;
                                    $invocant = Perlito5::Grammar::full_ident($str, $p);
                                    my $package = Perlito5::Match::flat($invocant);
                                    if ($package) {
                                        $invocant->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $package);
                                        if (substr($str, $invocant->{'to'}, 2) eq '::') {
                                            $invocant->{'to'} = $invocant->{'to'} + 2
                                        }
                                        elsif (!$Perlito5::PACKAGES->{$package}) {
                                            $invocant = undef
                                        }
                                    }
                                }
                                else {
                                    $invocant = Perlito5::Grammar::Bareword::the_object($str, $p)
                                }
                                if ($invocant) {
                                    $p = $invocant->{'to'};
                                    my $arg = [];
                                    $m = Perlito5::Grammar::Space::ws($str, $p);
                                    $m && ($p = $m->{'to'});
                                    if (substr($str, $p, 2) eq '->') {}
                                    elsif (substr($str, $p, 1) eq '(') {
                                        my $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                        if ($m) {
                                            $arg = $m->{'capture'}->[2];
                                            $p = $m->{'to'};
                                            $arg = Perlito5::Grammar::Expression::expand_list($arg)
                                        }
                                    }
                                    else {
                                        my $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                                        if ($m->{'capture'} ne '*undef*') {
                                            $arg = Perlito5::Grammar::Expression::expand_list($m->{'capture'});
                                            $p = $m->{'to'}
                                        }
                                    }
                                    $m_name->{'capture'} = ['term', Perlito5::AST::Call::->new('method' => $full_name, 'invocant' => Perlito5::Match::flat($invocant), 'arguments' => $arg)];
                                    $m_name->{'to'} = $p;
                                    return $m_name
                                }
                                if (substr($str, $p, 2) eq '=>') {
                                    $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
                                    $m_name->{'to'} = $p;
                                    return $m_name
                                }
                                if (substr($str, $p, 2) eq '->') {
                                    if ($is_subroutine_name) {
                                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [], 'code' => $name, 'namespace' => $namespace)]
                                    }
                                    else {
                                        $m_name->{'capture'} = ['term', Perlito5::AST::Var::->new('name' => '', 'namespace' => $full_name, 'sigil' => '::')]
                                    }
                                    $m_name->{'to'} = $p;
                                    return $m_name
                                }
                                my $sig;
                                if (exists($Perlito5::PROTO->{$effective_name})) {
                                    $sig = $Perlito5::PROTO->{$effective_name}
                                }
                                elsif ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                                    $effective_name = 'CORE::' . $name;
                                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                                }
                                else {
                                    my $m = Perlito5::Grammar::Number::val_version($str, $pos);
                                    if ($m) {
                                        $m->{'capture'} = ['term', $m->{'capture'}];
                                        return $m
                                    }
                                    $sig = undef
                                }
                                my $has_paren = 0;
                                if (defined($sig)) {
                                    my $arg_index = 1;
                                    my $optional = 0;
                                    my @args;
                                    my $sig_part = substr($sig, 0, 1);
                                    my $m;
                                    my $capture;
                                    if ($sig_part eq '&') {
                                        $m = Perlito5::Grammar::Space::ws($str, $p);
                                        $m && ($p = $m->{'to'});
                                        if (substr($str, $p, 1) ne '(') {
                                            $sig = substr($sig, 1);
                                            $m = Perlito5::Grammar::Bareword::prototype_is_ampersand($str, $p);
                                            $m && ($capture = $m->{'capture'});
                                            if (!$m) {
                                                die('Type of arg ' . $arg_index . ' to ' . $name . ' must be block or sub {}')
                                            }
                                            $p = $m->{'to'};
                                            push(@args, $capture)
                                        }
                                    }
                                    if (substr($sig, 0, 1) eq ';' && substr($str, $p, 2) eq '//') {
                                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [], 'bareword' => 1)];
                                        $m_name->{'to'} = $p;
                                        return $m_name
                                    }
                                    if ($sig eq '') {
                                        if (substr($str, $p, 1) eq '(') {
                                            $p++;
                                            $has_paren = 1;
                                            my $m = Perlito5::Grammar::Space::ws($str, $p);
                                            if ($m) {
                                                $p = $m->{'to'}
                                            }
                                            if (substr($str, $p, 1) ne ')') {
                                                die('syntax error near ', substr($str, $pos, 10))
                                            }
                                            $p++
                                        }
                                        if ($name eq '__FILE__') {
                                            $m_name->{'capture'} = ['term', Perlito5::AST::Buf::->new('buf' => $Perlito5::FILE_NAME)]
                                        }
                                        elsif ($name eq '__LINE__') {
                                            $m_name->{'capture'} = ['term', Perlito5::AST::Int::->new('int' => $Perlito5::LINE_NUMBER)]
                                        }
                                        else {
                                            $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0))]
                                        }
                                        $m_name->{'to'} = $p;
                                        return $m_name
                                    }
                                    if ($sig eq '_' || $sig eq '$' || $sig eq '+' || $sig eq ';$') {
                                        my $m;
                                        my $arg;
                                        if (substr($str, $p, 1) eq '(') {
                                            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                            if (!$m) {
                                                return $m
                                            }
                                            $p = $m->{'to'};
                                            $has_paren = 1;
                                            $arg = $m->{'capture'}->[2];
                                            $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                            my $v = shift(@{$arg});
                                            @{$arg} && die('Too many arguments for ' . $name);
                                            $arg = $v
                                        }
                                        else {
                                            $m = Perlito5::Grammar::Expression::argument_parse($str, $p);
                                            $arg = $m->{'capture'};
                                            if ($arg eq '*undef*') {
                                                $arg = undef
                                            }
                                            elsif (ref($arg) eq 'Perlito5::AST::Apply' && $arg->{'code'} eq 'circumfix:<( )>') {
                                                my $v = shift(@{$arg->{'arguments'}});
                                                @{$arg->{'arguments'}} && die('Too many arguments for ' . $name);
                                                $arg = $v
                                            }
                                        }
                                        if (defined($arg)) {
                                            push(@args, $arg);
                                            $has_paren = 1
                                        }
                                        else {
                                            $sig eq '$' && die('Not enough arguments for ' . $name);
                                            $sig eq '_' && push(@args, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                                        }
                                        my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
                                        if ($name eq 'eval' && !$namespace) {
                                            $ast->{'_scope'} = Perlito5::Grammar::Scope::get_snapshot()
                                        }
                                        $m->{'capture'} = ['term', $ast];
                                        return $m
                                    }
                                    if ($sig eq ';@') {
                                        if (substr($str, $p, 1) eq '(') {
                                            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                            $has_paren = 1;
                                            my $arg = $m->{'capture'}->[2];
                                            $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                            push(@args, @{$arg})
                                        }
                                        else {
                                            $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                                            my $arg = $m->{'capture'};
                                            if ($arg ne '*undef*') {
                                                $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                                push(@args, @{$arg})
                                            }
                                        }
                                        my $ast = Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => \@args, 'bareword' => ($has_paren == 0));
                                        $m->{'capture'} = ['term', $ast];
                                        return $m
                                    }
                                    if ($sig eq '*') {}
                                }
                                if (substr($str, $p, 1) eq '(') {
                                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                                    if (!$m) {
                                        return $m
                                    }
                                    my $arg = $m->{'capture'}->[2];
                                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                                    if ($namespace eq '' || $namespace eq 'CORE') {
                                        if ($name eq 'local' || $name eq 'my' || $name eq 'state' || $name eq 'our') {
                                            my $declarator = $name;
                                            for my $var (@{$arg}) {
                                                if (ref($var) eq 'Perlito5::AST::Apply' && $var->{'code'} eq 'undef') {}
                                                else {
                                                    my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => '', 'var' => $var, 'attributes' => []);
                                                    $var->{'_decl'} = $name;
                                                    $var->{'_id'} = $Perlito5::ID++;
                                                    $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                                                    $declarator eq 'local' && !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME)
                                                }
                                            }
                                        }
                                        if ($name eq 'print' || $name eq 'say') {
                                            if (@{$arg} == 0) {
                                                push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                                            }
                                        }
                                        if ($name eq 'split') {
                                            if (@{$arg} == 0) {
                                                push(@{$arg}, Perlito5::AST::Buf::->new('buf' => ' '))
                                            }
                                            if (@{$arg} == 1) {
                                                push(@{$arg}, Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))
                                            }
                                        }
                                    }
                                    $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => $arg, 'proto' => $sig)];
                                    return $m
                                }
                                my $m_list = Perlito5::Grammar::Expression::list_parse($str, $p);
                                my $list = $m_list->{'capture'};
                                if ($list ne '*undef*') {
                                    $m_name->{'capture'} = ['postfix_or_term', 'funcall', $namespace, $name, $list];
                                    $m_name->{'to'} = $m_list->{'to'};
                                    return $m_name
                                }
                                if ($namespace eq '' || $namespace eq 'CORE') {
                                    if ($name eq 'print' || $name eq 'say') {
                                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
                                        return $m_name
                                    }
                                    if ($name eq 'split' && ($namespace eq '' || $namespace eq 'CORE')) {
                                        $m_name->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => $name, 'namespace' => $namespace, 'arguments' => [Perlito5::AST::Buf::->new('buf' => ' '), Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')])];
                                        return $m_name
                                    }
                                }
                                $m_name->{'capture'} = ['postfix_or_term', 'funcall_no_params', $namespace, $name];
                                return $m_name
                            }
                            sub Perlito5::Grammar::Bareword::prototype_is_ampersand {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'});
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::AST::Sub::->new('attributes' => [], 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'name' => undef, 'namespace' => undef, 'sig' => undef);
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ((chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }) && ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::argument_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::argument_parse'});
                                            1
                                        }))
                                    })
                                }));
                                $tmp ? $MATCH : 0
                            }
                            1
                        }
                    }
                    {
                        {
                            package main;
                            undef();
                            package Perlito5::Grammar::Attribute;
                            sub Perlito5::Grammar::Attribute::opt_attribute {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my @attributes;
                                my $ws = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                if (substr($str, $ws->{'to'}, 1) ne ':') {
                                    return {'to' => $pos, 'capture' => []}
                                }
                                $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1);
                                my $p = $ws->{'to'};
                                my $m = Perlito5::Grammar::ident($str, $p);
                                !$m && die('syntax error');
                                my $to;
                                while (1) {
                                    my $attr = [Perlito5::Match::flat($m), undef];
                                    $to = $m->{'to'};
                                    my $delimiter = substr($str, $to, 1);
                                    if ($delimiter eq '(') {
                                        my $params = Perlito5::Grammar::String::string_interpolation_parse($str, $m->{'to'} + 1, '(', ')', 0);
                                        !$params && die('syntax error');
                                        $attr->[1] = Perlito5::Match::flat($params)->{'buf'};
                                        $to = $params->{'to'}
                                    }
                                    push(@attributes, $attr);
                                    $ws = Perlito5::Grammar::Space::opt_ws($str, $to);
                                    if (substr($str, $ws->{'to'}, 1) eq ':') {
                                        $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{'to'} + 1)
                                    }
                                    $p = $ws->{'to'};
                                    $m = Perlito5::Grammar::ident($str, $p);
                                    !$m && return {'to' => $to, 'capture' => \@attributes}
                                }
                            }
                            1
                        }
                    }
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Statement;
                            {
                                {
                                    package main;
                                    undef();
                                    package Perlito5::Macro;
                                    use strict;
                                    {
                                        package Perlito5::AST::Apply;
                                        use strict;
                                        my %op = ('infix:<+=>' => 'infix:<+>', 'infix:<-=>' => 'infix:<->', 'infix:<*=>' => 'infix:<*>', 'infix:</=>' => 'infix:</>', 'infix:<||=>' => 'infix:<||>', 'infix:<&&=>' => 'infix:<&&>', 'infix:<|=>' => 'infix:<|>', 'infix:<&=>' => 'infix:<&>', 'infix:<//=>' => 'infix:<//>', 'infix:<.=>' => 'list:<.>', 'infix:<x=>' => 'infix:<x>');
                                        sub Perlito5::AST::Apply::op_assign {
                                            my $self = $_[0];
                                            my $code = $self->{'code'};
                                            ref($code) && return 0;
                                            if (exists($op{$code})) {
                                                return Perlito5::AST::Apply::->new('code' => 'infix:<=>', 'arguments' => [$self->{'arguments'}->[0], Perlito5::AST::Apply::->new('code' => $op{$code}, 'arguments' => $self->{'arguments'})])
                                            }
                                            return 0
                                        }
                                        my %op_auto = ('prefix:<++>' => 1, 'prefix:<-->' => 1, 'postfix:<++>' => 1, 'postfix:<-->' => 1);
                                        sub Perlito5::AST::Apply::op_auto {
                                            my $self = $_[0];
                                            my $code = $self->{'code'};
                                            ref($code) && return 0;
                                            if (exists($op_auto{$code})) {
                                                my $paren = $self->{'arguments'}->[0];
                                                if ($paren->{'code'} eq 'circumfix:<( )>') {
                                                    my $arg = $paren->{'arguments'}->[-1];
                                                    if ($arg->{'code'} eq 'infix:<=>') {
                                                        my $var = $arg->{'arguments'}->[0];
                                                        return Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::AST::Block::->new('stmts' => [$paren, Perlito5::AST::Apply::->new('code' => $code, 'arguments' => [$var])])])
                                                    }
                                                }
                                            }
                                            return 0
                                        }
                                    }
                                    sub Perlito5::Macro::while_file {
                                        my $self = $_[0];
                                        ref($self) ne 'Perlito5::AST::While' && return 0;
                                        my $cond = $self->{'cond'};
                                        if ($cond->isa('Perlito5::AST::Apply') && ($cond->{'code'} eq 'readline')) {
                                            $self->{'cond'} = bless({'arguments' => [bless({'arguments' => [Perlito5::AST::Var::->new('name' => '_', 'namespace' => '', 'sigil' => '$'), $cond], 'code' => 'infix:<=>', 'namespace' => ''}, 'Perlito5::AST::Apply')], 'bareword' => '', 'code' => 'defined', 'namespace' => ''}, 'Perlito5::AST::Apply');
                                            return $self
                                        }
                                        return 0
                                    }
                                }
                            }
                            my @Statement_chars;
                            my %Statement;
                            sub Perlito5::Grammar::Statement::add_statement {
                                my $name = shift;
                                my $param = shift;
                                $Statement{$name} = $param;
                                unshift(@Statement_chars, scalar(@Statement_chars) + 1)
                                    while @Statement_chars < length($name)
                            }
                            sub Perlito5::Grammar::Statement::stmt_yadayada {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('...' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'die', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => 'Unimplemented')]);
                                    1
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Statement::stmt_format {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('format' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (do {
                                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'Perlito5::Grammar::full_ident'} = 'STDOUT';
                                            1
                                        })
                                    })
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
                                    push(@Perlito5::Grammar::String::Here_doc, ['single_quote', $placeholder->{'arguments'}->[0]->{'arguments'}, '.']);
                                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:format', 'namespace' => '', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), $placeholder]);
                                    1
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Statement::stmt_package {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                                my $tmp = ((('package' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                            $MATCH->{'_package'} = $Perlito5::PKG_NAME;
                                            $Perlito5::PACKAGES->{$name} = 1;
                                            $Perlito5::PKG_NAME = $name;
                                            1
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})), @{$MATCH->{'Perlito5::Grammar::block'}->{'capture'}->{'stmts'}}]);
                                            $Perlito5::PKG_NAME = $MATCH->{'_package'};
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                            $Perlito5::PACKAGES->{$name} = 1;
                                            $Perlito5::PKG_NAME = $name;
                                            $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'package', 'arguments' => [], 'namespace' => $name);
                                            1
                                        })
                                    })
                                })));
                                $tmp ? $MATCH : 0
                            }
                            sub Perlito5::Grammar::Statement::exp_stmt {
                                my $str = $_[0];
                                my $pos = $_[1];
                                for my $len (@Statement_chars) {
                                    my $term = substr($str, $pos, $len);
                                    if (exists($Statement{$term})) {
                                        my $m = $Statement{$term}->($str, $pos);
                                        $m && return $m
                                    }
                                }
                                return 0
                            }
                            my @Modifier_chars = (7, 6, 5, 4, 3, 2);
                            my %Modifier = ('if' => 1, 'unless' => 1, 'when' => 1, 'for' => 1, 'foreach' => 1, 'while' => 1, 'until' => 1, 'given' => 1);
                            sub Perlito5::Grammar::Statement::statement_modifier {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $expression = $_[2];
                                for my $len (@Modifier_chars) {
                                    my $term = substr($str, $pos, $len);
                                    if (exists($Modifier{$term})) {
                                        my $m = modifier($str, $pos + $len, $term, $expression);
                                        $m && return $m
                                    }
                                }
                                return 0
                            }
                            sub Perlito5::Grammar::Statement::modifier {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $modifier = $_[2];
                                my $expression = $_[3];
                                my $modifier_exp = Perlito5::Grammar::Expression::exp_parse($str, $pos);
                                if (!$modifier_exp) {
                                    die('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
                                }
                                if ($modifier eq 'if') {
                                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<&&>', 'namespace' => '')}
                                }
                                if ($modifier eq 'unless') {
                                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp), $expression], 'code' => 'infix:<||>', 'namespace' => '')}
                                }
                                if ($modifier eq 'when') {
                                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression)}
                                }
                                if ($modifier eq 'while') {
                                    my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression);
                                    my $out = Perlito5::Macro::while_file($stmt);
                                    $out && ($stmt = $out);
                                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
                                }
                                if ($modifier eq 'until') {
                                    my $stmt = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [Perlito5::Match::flat($modifier_exp)], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => $expression);
                                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => $stmt}
                                }
                                if ($modifier eq 'for' || $modifier eq 'foreach') {
                                    return {'str' => $str, 'from' => $pos, 'to' => $modifier_exp->{'to'}, 'capture' => Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($modifier_exp), 'body' => $expression, 'topic' => Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$'))}
                                }
                                die('Unexpected statement modifier ' . chr(39) . $modifier . chr(39))
                            }
                            sub Perlito5::Grammar::Statement::statement_parse {
                                my $m = statement_parse_inner(@_);
                                !@Perlito5::SCOPE_STMT && return $m;
                                Perlito5::Grammar::Scope::check_variable_declarations();
                                return $m
                            }
                            sub Perlito5::Grammar::Statement::statement_parse_inner {
                                my $str = $_[0];
                                my $pos = $_[1];
                                my $res = exp_stmt($str, $pos);
                                if ($res) {
                                    return $res
                                }
                                $res = Perlito5::Grammar::Expression::exp_parse($str, $pos);
                                if (!$res) {
                                    return 
                                }
                                if (substr($str, $res->{'to'}, 1) eq ':' && $res->{'capture'}->isa('Perlito5::AST::Apply') && $res->{'capture'}->{'bareword'}) {
                                    my $label = $res->{'capture'}->{'code'};
                                    my $ws = Perlito5::Grammar::Space::opt_ws($str, $res->{'to'} + 1);
                                    my $stmt = statement_parse($str, $ws->{'to'});
                                    if ($stmt) {
                                        $stmt->{'capture'}->{'label'} = $label;
                                        return $stmt
                                    }
                                    $res->{'to'} = $ws->{'to'};
                                    $res->{'capture'} = Perlito5::AST::Apply::->new('arguments' => [], 'code' => 'undef', 'namespace' => '', 'label' => $label);
                                    return $res
                                }
                                my $modifier = statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res));
                                my $p = $modifier ? $modifier->{'to'} : $res->{'to'};
                                my $terminator = substr($str, $p, 1);
                                $terminator ne ';' && $terminator ne '}' && $terminator ne '' && die('Number or Bareword found where operator expected');
                                if (!$modifier) {
                                    return $res
                                }
                                return $modifier
                            }
                            Perlito5::Grammar::Statement::add_statement('...' => \&stmt_yadayada);
                            Perlito5::Grammar::Statement::add_statement('package' => \&stmt_package);
                            Perlito5::Grammar::Statement::add_statement('format' => \&stmt_format);
                            1
                        }
                    }
                    sub Perlito5::Grammar::Expression::expand_list {
                        my $param_list = shift;
                        if (ref($param_list) eq 'Perlito5::AST::Apply' && $param_list->code() eq 'list:<,>') {
                            return [grep {
                                defined($_)
                            } @{$param_list->arguments()}]
                        }
                        elsif ($param_list eq '*undef*') {
                            return []
                        }
                        else {
                            return [$param_list]
                        }
                    }
                    sub Perlito5::Grammar::Expression::block_or_hash {
                        my $o = shift;
                        if (defined($o->sig())) {
                            return $o
                        }
                        my $stmts = $o->stmts();
                        if (!(defined($stmts)) || scalar(@{$stmts}) == 0) {
                            return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [])
                        }
                        if (scalar(@{$stmts}) != 1) {
                            return $o
                        }
                        my $stmt = $stmts->[0];
                        if (ref($stmt) eq 'Perlito5::AST::Var') {
                            return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
                        }
                        if (ref($stmt) ne 'Perlito5::AST::Apply') {
                            return $o
                        }
                        if ($stmt->code() eq 'infix:<=>>' || $stmt->code() eq 'prefix:<%>' || $stmt->code() eq 'prefix:<@>') {
                            return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => [$stmt])
                        }
                        if ($stmt->code() ne 'list:<,>') {
                            return $o
                        }
                        return Perlito5::AST::Apply::->new('code' => 'circumfix:<{ }>', 'namespace' => '', 'arguments' => expand_list($stmt))
                    }
                    sub Perlito5::Grammar::Expression::pop_term {
                        my $num_stack = shift;
                        my $v = pop(@{$num_stack});
                        if (ref($v) eq 'ARRAY') {
                            ref($v->[1]) && return $v->[1];
                            if ($v->[1] eq 'methcall_no_params') {
                                $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => []);
                                return $v
                            }
                            if ($v->[1] eq 'funcall_no_params') {
                                $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'namespace' => $v->[2], 'arguments' => [], 'bareword' => 1);
                                return $v
                            }
                            if ($v->[1] eq 'methcall') {
                                my $param_list = expand_list(($v->[3]));
                                $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => $v->[2], 'arguments' => $param_list);
                                return $v
                            }
                            if ($v->[1] eq 'funcall') {
                                my $param_list = expand_list(($v->[4]));
                                $v = Perlito5::AST::Apply::->new('code' => $v->[3], 'arguments' => $param_list, 'namespace' => $v->[2]);
                                return $v
                            }
                            if ($v->[1] eq '( )') {
                                my $param_list = expand_list($v->[2]);
                                $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<( )>', 'arguments' => $param_list, 'namespace' => '');
                                return $v
                            }
                            if ($v->[1] eq '[ ]') {
                                my $param_list = expand_list($v->[2]);
                                $v = Perlito5::AST::Apply::->new('code' => 'circumfix:<[ ]>', 'arguments' => $param_list, 'namespace' => '');
                                return $v
                            }
                            if ($v->[1] eq 'block') {
                                $v = Perlito5::AST::Block::->new('stmts' => $v->[2], 'sig' => $v->[3]);
                                $v = block_or_hash($v);
                                return $v
                            }
                            if ($v->[1] eq '.( )') {
                                $v = Perlito5::AST::Call::->new('invocant' => undef, 'method' => 'postcircumfix:<( )>', 'arguments' => $v->[2]);
                                return $v
                            }
                            if ($v->[1] eq '.[ ]') {
                                $v = Perlito5::AST::Index::->new('obj' => undef, 'index_exp' => $v->[2]);
                                return $v
                            }
                            if ($v->[1] eq '.{ }') {
                                $v = Perlito5::AST::Lookup::->new('obj' => undef, 'index_exp' => $v->[2]);
                                return $v
                            }
                            return $v->[1]
                        }
                        return $v
                    }
                    sub Perlito5::Grammar::Expression::reduce_postfix {
                        my $op = shift;
                        my $value = shift;
                        my $v = $op;
                        if ($v->[1] eq 'methcall_no_params') {
                            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => []);
                            return $v
                        }
                        if ($v->[1] eq 'funcall_no_params') {
                            die('Bareword found where operator expected')
                        }
                        if ($v->[1] eq 'methcall') {
                            my $param_list = expand_list($v->[3]);
                            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => $v->[2], 'arguments' => $param_list);
                            return $v
                        }
                        if ($v->[1] eq 'funcall') {
                            die('unexpected function call')
                        }
                        if ($v->[1] eq '( )') {
                            my $param_list = expand_list($v->[2]);
                            if (ref($value) eq 'Perlito5::AST::Apply' && !(defined($value->arguments()))) {
                                $value->{'arguments'} = $param_list;
                                return $value
                            }
                            if (ref($value) eq 'Perlito5::AST::Call' && !(defined($value->arguments()))) {
                                $value->{'arguments'} = $param_list;
                                return $value
                            }
                            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
                            return $v
                        }
                        if ($v->[1] eq '[ ]') {
                            if (ref($value) eq 'Perlito5::AST::Var') {
                                $value->{'_real_sigil'} = '@'
                            }
                            $v = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $v->[2]);
                            return $v
                        }
                        if ($v->[1] eq 'block') {
                            if (ref($value) eq 'Perlito5::AST::Var') {
                                $value->{'_real_sigil'} = '%'
                            }
                            $v = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => $v->[2]->[0]);
                            return $v
                        }
                        if ($v->[1] eq '.( )') {
                            my $param_list = expand_list($v->[2]);
                            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<( )>', 'arguments' => $param_list);
                            return $v
                        }
                        if ($v->[1] eq '.[ ]') {
                            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<[ ]>', 'arguments' => $v->[2]);
                            return $v
                        }
                        if ($v->[1] eq '.{ }') {
                            $v = Perlito5::AST::Call::->new('invocant' => $value, 'method' => 'postcircumfix:<{ }>', 'arguments' => $v->[2]);
                            return $v
                        }
                        push(@{$op}, $value);
                        return $op
                    }
                    my $reduce_to_ast = sub {
                        my $op_stack = shift;
                        my $num_stack = shift;
                        my $last_op = shift(@{$op_stack});
                        if ($last_op->[0] eq 'prefix') {
                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'prefix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
                        }
                        elsif ($last_op->[0] eq 'postfix') {
                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'postfix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack)]))
                        }
                        elsif ($last_op->[0] eq 'postfix_or_term') {
                            push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)))
                        }
                        elsif (Perlito5::Grammar::Precedence::is_assoc_type('list', $last_op->[1])) {
                            my $arg;
                            if (scalar(@{$num_stack}) < 2) {
                                my $v2 = pop_term($num_stack);
                                if (ref($v2) eq 'Perlito5::AST::Apply' && $v2->code() eq ('list:<' . $last_op->[1] . '>')) {
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => $v2->namespace(), 'code' => $v2->code(), 'arguments' => [@{$v2->arguments()}]))
                                }
                                else {
                                    push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => [$v2]))
                                }
                                return 
                            }
                            else {
                                my $v2 = pop_term($num_stack);
                                $arg = [pop_term($num_stack), $v2]
                            }
                            if (ref($arg->[0]) eq 'Perlito5::AST::Apply' && $last_op->[0] eq 'infix' && ($arg->[0]->code() eq 'list:<' . $last_op->[1] . '>')) {
                                push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => ($arg->[0])->code(), 'arguments' => [@{($arg->[0])->arguments()}, $arg->[1]]));
                                return 
                            }
                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<' . $last_op->[1] . '>', 'arguments' => $arg))
                        }
                        elsif (Perlito5::Grammar::Precedence::is_assoc_type('chain', $last_op->[1])) {
                            if (scalar(@{$num_stack}) < 2) {
                                die('Missing value after operator ' . $last_op->[1])
                            }
                            my $v2 = pop_term($num_stack);
                            my $arg = [pop_term($num_stack), $v2];
                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => $arg))
                        }
                        elsif ($last_op->[0] eq 'ternary') {
                            if (scalar(@{$num_stack}) < 2) {
                                die('Missing value after ternary operator')
                            }
                            my $v2 = pop_term($num_stack);
                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ternary:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $last_op->[2], $v2]))
                        }
                        else {
                            if (scalar(@{$num_stack}) < 2) {
                                die('missing value after operator ' . chr(39) . $last_op->[1] . chr(39))
                            }
                            my $v2 = pop_term($num_stack);
                            push(@{$num_stack}, Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'infix:<' . $last_op->[1] . '>', 'arguments' => [pop_term($num_stack), $v2]))
                        }
                    };
                    sub Perlito5::Grammar::Expression::term_arrow {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('->' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = square_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'square_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = curly_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'curly_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            die('Missing right curly or square bracket');
                                            1
                                        })
                                    })
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = paren_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'paren_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'})), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}))];
                                            1
                                        })
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $m2 = paren_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'paren_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'}), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'})];
                                            1
                                        })
                                    })
                                }))
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_ternary {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('?' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = ternary5_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'ternary5_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (':' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_paren {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_square {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = square_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'square_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_curly {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m = $MATCH;
                            if (!(do {
                                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            })) {
                                $MATCH = $m
                            }
                            1
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m = $MATCH;
                                    if (!(do {
                                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['postfix_or_term', 'block', [Perlito5::AST::Apply::->new('arguments' => [], 'bareword' => 1, 'code' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), 'namespace' => '')]];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'_save_scope'} = [@Perlito5::SCOPE_STMT];
                                    @Perlito5::SCOPE_STMT = ();
                                    1
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::exp_stmts'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    @Perlito5::SCOPE_STMT = @{$MATCH->{'_save_scope'}};
                                    1
                                }) && (do {
                                    my $m = $MATCH;
                                    if (!(do {
                                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('}' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            die('Missing right curly or square bracket');
                                            1
                                        })
                                    })
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::exp_stmts'})];
                                    1
                                }))
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::declarator {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('my' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('state' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('our' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_declarator {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = declarator($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'declarator'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Block::named_sub($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Block::named_sub'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            my $sub = $MATCH->{'Perlito5::Grammar::Block::named_sub'}->{'capture'};
                                            $sub->{'decl'} = Perlito5::Match::flat($MATCH->{'declarator'});
                                            $MATCH->{'capture'} = ['term', $sub];
                                            return $MATCH;
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            my $m2 = Perlito5::Grammar::opt_type($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::opt_type'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                1
                            })
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::var_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $declarator = Perlito5::Match::flat($MATCH->{'declarator'});
                            my $type = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::opt_type'});
                            $type && !$Perlito5::PACKAGES->{$type} && die('No such class ' . $type);
                            my $var = $MATCH->{'Perlito5::Grammar::var_ident'}->{'capture'};
                            $var->{'namespace'} && die('No package name allowed for variable ' . $var->{'sigil'} . $var->{'name'} . ' in "' . $declarator . '"');
                            $var->{'_decl'} = $declarator;
                            $var->{'_id'} = $Perlito5::ID++;
                            $declarator eq 'our' && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                            my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var, 'attributes' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'}));
                            $MATCH->{'capture'} = ['term', $decl];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_not {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('not' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'prefix:<not>', 'arguments' => expand_list(Perlito5::Match::flat($MATCH->{'paren_parse'})), 'namespace' => '')];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_local {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('local' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $declarator = 'local';
                            my $type = '';
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                            $MATCH = Perlito5::Grammar::String::double_quoted_var_with_subscript($MATCH);
                            my $var = $MATCH->{'capture'};
                            my $look = Perlito5::Grammar::Scope::lookup_variable($var);
                            if ($look && ($look->{'_decl'} eq 'my' || $look->{'_decl'} eq 'state')) {
                                die('Can' . chr(39) . 't localize lexical variable ' . $var->{'sigil'} . $var->{'name'})
                            }
                            $var->{'_id'} = $Perlito5::ID++;
                            $var->{'_decl'} = $declarator;
                            !$var->{'namespace'} && !$var->{'_namespace'} && ($var->{'_namespace'} = $Perlito5::PKG_NAME);
                            my $decl = Perlito5::AST::Decl::->new('decl' => $declarator, 'type' => $type, 'var' => $var);
                            $MATCH->{'capture'} = ['term', $decl];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_return {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('return' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = list_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'list_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $args = Perlito5::Match::flat($MATCH->{'list_parse'});
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'return', 'arguments' => $args eq '*undef*' ? [] : [$args], 'namespace' => '')];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Expression::term_eval {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('eval' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})], 'namespace' => '')];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
                    my $Expr_end_token = {']' => 1, ')' => 1, '}' => 1, ';' => 1, 'if' => 1, 'for' => 1, 'else' => 1, 'when' => 1, 'while' => 1, 'until' => 1, 'elsif' => 1, 'unless' => 1, 'foreach' => 1};
                    my $List_end_token = {':' => 1, 'or' => 1, 'and' => 1, 'xor' => 1, %{$Expr_end_token}};
                    my $Argument_end_token = {',' => 1, '<' => 1, '>' => 1, '=' => 1, '|' => 1, '^' => 1, '?' => 1, '=>' => 1, 'lt' => 1, 'le' => 1, 'gt' => 1, 'ge' => 1, '<=' => 1, '>=' => 1, '==' => 1, '!=' => 1, 'ne' => 1, 'eq' => 1, '..' => 1, '~~' => 1, '&&' => 1, '||' => 1, '+=' => 1, '-=' => 1, '*=' => 1, '/=' => 1, 'x=' => 1, '|=' => 1, '&=' => 1, '.=' => 1, '^=' => 1, '%=' => 1, '//' => 1, '...' => 1, '<=>' => 1, 'cmp' => 1, '<<=' => 1, '>>=' => 1, '||=' => 1, '&&=' => 1, '//=' => 1, '**=' => 1, %{$List_end_token}};
                    sub Perlito5::Grammar::Expression::list_parser {
                        my($str, $pos, $end_token) = @_;
                        my $expr;
                        my $last_pos = $pos;
                        my $is_first_token = 1;
                        my $lexer_stack = [];
                        my $last_token_was_space = 1;
                        my $get_token = sub {
                            my $last_is_term = $_[0];
                            my $v;
                            if (scalar(@{$lexer_stack})) {
                                $v = pop(@{$lexer_stack});
                                if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                                    $v->[0] = 'end'
                                }
                            }
                            else {
                                my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                                if ($m) {
                                    my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                                    if ($spc) {
                                        $m->{'to'} = $spc->{'to'}
                                    }
                                }
                                if (!$m) {
                                    return ['end', '*end*']
                                }
                                $v = $m->{'capture'};
                                if ($is_first_token && ($v->[0] eq 'op') && !(Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))) {
                                    $v->[0] = 'end'
                                }
                                if ($v->[0] ne 'end') {
                                    $last_pos = $m->{'to'}
                                }
                            }
                            $last_token_was_space = ($v->[0] eq 'space');
                            $is_first_token = 0;
                            return $v
                        };
                        my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $end_token, 'end_token_chars' => $Expr_end_token_chars);
                        my $res = $prec->precedence_parse();
                        if (scalar(@{$res}) == 0) {
                            return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => '*undef*'}
                        }
                        my $result = pop_term($res);
                        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
                    }
                    sub Perlito5::Grammar::Expression::argument_parse {
                        my($str, $pos) = @_;
                        return list_parser($str, $pos, $Argument_end_token)
                    }
                    sub Perlito5::Grammar::Expression::list_parse {
                        my($str, $pos) = @_;
                        return list_parser($str, $pos, $List_end_token)
                    }
                    sub Perlito5::Grammar::Expression::circumfix_parse {
                        my($str, $pos, $delimiter) = @_;
                        my $expr;
                        my $last_pos = $pos;
                        my $get_token = sub {
                            my $last_is_term = $_[0];
                            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                            if ($m) {
                                my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                                if ($spc) {
                                    $m->{'to'} = $spc->{'to'}
                                }
                            }
                            if (!$m) {
                                my $msg = 'Expected closing delimiter: ' . $delimiter;
                                ($delimiter eq '}' || $delimiter eq ']') && ($msg = 'Missing right curly or square bracket');
                                die($msg . ' near ', $last_pos)
                            }
                            my $v = $m->{'capture'};
                            if ($v->[0] ne 'end') {
                                $last_pos = $m->{'to'}
                            }
                            return $v
                        };
                        my %delim_token;
                        $delim_token{$delimiter} = 1;
                        my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => \%delim_token, 'end_token_chars' => [length($delimiter)]);
                        my $res = $prec->precedence_parse();
                        $res = pop_term($res);
                        if (!(defined($res))) {
                            $res = '*undef*'
                        }
                        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $res}
                    }
                    sub Perlito5::Grammar::Expression::ternary5_parse {
                        return circumfix_parse(@_, ':')
                    }
                    sub Perlito5::Grammar::Expression::curly_parse {
                        return circumfix_parse(@_, '}')
                    }
                    sub Perlito5::Grammar::Expression::square_parse {
                        return circumfix_parse(@_, ']')
                    }
                    sub Perlito5::Grammar::Expression::paren_parse {
                        return circumfix_parse(@_, ')')
                    }
                    sub Perlito5::Grammar::Expression::exp_parse {
                        my($str, $pos) = @_;
                        my $expr;
                        my $last_pos = $pos;
                        my $lexer_stack = [];
                        my $get_token = sub {
                            my $last_is_term = $_[0];
                            my $v;
                            if (scalar(@{$lexer_stack})) {
                                $v = pop(@{$lexer_stack})
                            }
                            else {
                                my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                                if ($m) {
                                    my $spc = Perlito5::Grammar::Space::ws($str, $m->{'to'});
                                    if ($spc) {
                                        $m->{'to'} = $spc->{'to'}
                                    }
                                }
                                if (!$m) {
                                    return ['end', '*end*']
                                }
                                $v = $m->{'capture'};
                                if ($v->[0] ne 'end') {
                                    $last_pos = $m->{'to'}
                                }
                            }
                            return $v
                        };
                        my $prec = Perlito5::Grammar::Precedence::->new('get_token' => $get_token, 'reduce' => $reduce_to_ast, 'end_token' => $Expr_end_token, 'end_token_chars' => $Expr_end_token_chars);
                        my $res = $prec->precedence_parse();
                        if (scalar(@{$res}) == 0) {
                            return 0
                        }
                        my $result = pop_term($res);
                        return {'str' => $str, 'from' => $pos, 'to' => $last_pos, 'capture' => $result}
                    }
                    Perlito5::Grammar::Precedence::add_term('my' => \&term_declarator);
                    Perlito5::Grammar::Precedence::add_term('our' => \&term_declarator);
                    Perlito5::Grammar::Precedence::add_term('eval' => \&term_eval);
                    Perlito5::Grammar::Precedence::add_term('state' => \&term_declarator);
                    Perlito5::Grammar::Precedence::add_term('local' => \&term_local);
                    Perlito5::Grammar::Precedence::add_term('return' => \&term_return);
                    Perlito5::Grammar::Precedence::add_term('not' => \&term_not);
                    1
                }
            }
            undef();
            {
                {
                    package main;
                    package Perlito5::Grammar;
                    use strict;
                    undef();
                    undef();
                    sub Perlito5::Grammar::unless {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('unless' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('else' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = block2($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block2'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block2'}), 'otherwise' => Perlito5::Match::flat($MATCH->{'block'}));
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::AST::Block::->new('stmts' => []), 'otherwise' => Perlito5::Match::flat($MATCH->{'block'}));
                                    1
                                })
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::if_ {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('if' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('else' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = block2($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block2'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::Match::flat($MATCH->{'block2'}));
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('els' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                    my $m2 = if_($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'if_'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::AST::Block::->new('stmts' => [Perlito5::Match::flat($MATCH->{'if_'})]));
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::If::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'otherwise' => Perlito5::AST::Block::->new('stmts' => []));
                                    1
                                })
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::when {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('when' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::term_paren'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::When::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_paren'})->[2], 'body' => Perlito5::Match::flat($MATCH->{'block'}));
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::for {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('for' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                            my $m = $MATCH;
                            if (!('each' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))) {
                                $MATCH = $m
                            }
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::term_declarator($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::term_declarator'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::term_declarator'})->[1];
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                            1
                                        }))
                                    })
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = opt_continue_block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'opt_continue_block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $body = Perlito5::Match::flat($MATCH->{'block'});
                                    $MATCH->{'capture'} = Perlito5::AST::For::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'}), 'body' => $body, 'continue' => $MATCH->{'opt_continue_block'}->{'capture'}, 'topic' => $MATCH->{'_tmp'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            Perlito5::Grammar::Scope::check_variable_declarations();
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ()
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }))
                                    })
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'c_style_for'} = 1;
                                            1
                                        }) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                ((do {
                                                    my $m2 = Perlito5::Grammar::exp($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::exp'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }) && (do {
                                                    $MATCH->{'str'} = $str;
                                                    Perlito5::Grammar::Scope::check_variable_declarations();
                                                    1
                                                }))
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ()
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })
                                            })
                                        }) && (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $pos1 = $MATCH->{'to'};
                                            (do {
                                                (do {
                                                    my $m2 = Perlito5::Grammar::exp2($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::exp2'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                ()
                                            }) || (do {
                                                $MATCH->{'to'} = $pos1;
                                                (do {
                                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })
                                            })
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        1
                                    })
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = opt_continue_block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'opt_continue_block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $header;
                                    my $body = Perlito5::Match::flat($MATCH->{'block'});
                                    my $topic;
                                    if ($MATCH->{'c_style_for'}) {
                                        $header = [$MATCH->{'Perlito5::Grammar::Expression::exp_parse'}->{'capture'}, $MATCH->{'Perlito5::Grammar::exp'}->{'capture'}, $MATCH->{'Perlito5::Grammar::exp2'}->{'capture'}]
                                    }
                                    else {
                                        $header = $MATCH->{'Perlito5::Grammar::Expression::exp_parse'}->{'capture'};
                                        $topic = Perlito5::AST::Var::->new('namespace' => '', 'name' => '_', 'sigil' => '$')
                                    }
                                    $MATCH->{'capture'} = Perlito5::AST::For::->new('cond' => $header, 'body' => $body, 'continue' => $MATCH->{'opt_continue_block'}->{'capture'}, 'topic' => $topic);
                                    1
                                }))
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::while {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('while' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = opt_continue_block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'opt_continue_block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $cond = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'});
                            if ($cond eq '*undef*') {
                                $cond = Perlito5::AST::Int::->new('int' => 1)
                            }
                            my $stmt = Perlito5::AST::While::->new('cond' => $cond, 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'continue' => $MATCH->{'opt_continue_block'}->{'capture'});
                            my $out = Perlito5::Macro::while_file($stmt);
                            $out && ($stmt = $out);
                            $MATCH->{'capture'} = $stmt;
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::until {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('until' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = opt_continue_block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'opt_continue_block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $cond = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'});
                            if ($cond eq '*undef*') {
                                $cond = Perlito5::AST::Int::->new('int' => 1)
                            }
                            $MATCH->{'capture'} = Perlito5::AST::While::->new('cond' => Perlito5::AST::Apply::->new('arguments' => [$cond], 'code' => 'prefix:<!>', 'namespace' => ''), 'body' => Perlito5::Match::flat($MATCH->{'block'}), 'continue' => $MATCH->{'opt_continue_block'}->{'capture'});
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::given {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('given' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::create_new_compile_time_scope();
                            1
                        }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::paren_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $body = Perlito5::Match::flat($MATCH->{'block'});
                            $body->{'sig'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::var_ident'});
                            $MATCH->{'capture'} = Perlito5::AST::Given::->new('cond' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::paren_parse'}), 'body' => $body);
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            Perlito5::Grammar::Scope::end_compile_time_scope();
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    Perlito5::Grammar::Statement::add_statement('if' => \&if_);
                    Perlito5::Grammar::Statement::add_statement('for' => \&for);
                    Perlito5::Grammar::Statement::add_statement('foreach' => \&for);
                    Perlito5::Grammar::Statement::add_statement('when' => \&when);
                    Perlito5::Grammar::Statement::add_statement('while' => \&while);
                    Perlito5::Grammar::Statement::add_statement('until' => \&until);
                    Perlito5::Grammar::Statement::add_statement('given' => \&given);
                    Perlito5::Grammar::Statement::add_statement('unless' => \&unless)
                }
            }
            {
                {
                    package main;
                    undef();
                    package Perlito5::Grammar::String;
                    undef();
                    sub Perlito5::Grammar::String::term_q_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('q' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }) && (do {
                            my $m2 = q_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'q_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'q_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_qq_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('qq' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('"' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }) && (do {
                            my $m2 = qq_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'qq_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qq_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_qw_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('qw' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 0 : 1
                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                            })
                        }) && (do {
                            my $m2 = qw_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'qw_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qw_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_m_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('m' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('/' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }) && (do {
                            my $m2 = m_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'m_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'m_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_s_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('s' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 0 : 1
                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                            })
                        }) && (do {
                            my $m2 = s_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'s_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'s_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_qx {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('qx' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('`' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }) && (do {
                            my $m2 = qx_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'qx_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qx_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_glob {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = glob_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'glob_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'glob_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_tr_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('tr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('y' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 0 : 1
                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                            })
                        }) && (do {
                            my $m2 = tr_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'tr_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'tr_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::term_qr_quote {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('qr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 0 : 1
                                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                            })
                        }) && (do {
                            my $m2 = qr_quote_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'qr_quote_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qr_quote_parse'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    my %pair = ('{' => '}', '(' => ')', '[' => ']', '<' => '>');
                    my %escape_sequence = ('a', 7, 'b', 8, 'e', 27, 'f', 12, 'n', 10, 'r', 13, 't', 9);
                    my %hex = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F');
                    my %octal = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7);
                    sub Perlito5::Grammar::String::q_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                        return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
                    }
                    sub Perlito5::Grammar::String::qq_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                        return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
                    }
                    sub Perlito5::Grammar::String::qw_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
                        if ($m) {
                            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'list:<,>', 'arguments' => [map(Perlito5::AST::Buf::->new('buf' => $_), split(' ', Perlito5::Match::flat($m)->{'buf'}))], 'namespace' => '')
                        }
                        return $m
                    }
                    sub Perlito5::Grammar::String::m_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        my $closing_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                        my $interpolate = 2;
                        $delimiter eq chr(39) && ($interpolate = 3);
                        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
                        $part1 || return $part1;
                        my $str_regex = $part1->{'capture'};
                        my $p = $part1->{'to'};
                        my $modifiers = '';
                        my $m = Perlito5::Grammar::ident($str, $p);
                        if ($m) {
                            $modifiers = Perlito5::Match::flat($m);
                            $part1->{'to'} = $m->{'to'}
                        }
                        $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:m', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
                        return $part1
                    }
                    sub Perlito5::Grammar::String::s_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        my $closing_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
                        $part1 || return $part1;
                        my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
                        my $part2;
                        my $m;
                        my $p = $part1->{'to'};
                        if (exists($pair{$delimiter})) {
                            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                            $p = $m->{'to'};
                            $delimiter = substr($str, $p, 1);
                            my $open_delimiter = $delimiter;
                            $p++;
                            $closing_delimiter = $delimiter;
                            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                            $part2 || return $part2
                        }
                        else {
                            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                            $part2 || return $part2
                        }
                        $p = $part2->{'to'};
                        my $modifiers = '';
                        $m = Perlito5::Grammar::ident($str, $p);
                        if ($m) {
                            $modifiers = Perlito5::Match::flat($m)
                        }
                        my $replace;
                        if ($modifiers =~ m!e!) {
                            delete($part2->{'capture'});
                            $replace = Perlito5::Match::flat($part2);
                            $replace = substr($replace, 0, -1);
                            $replace = '{' . $replace . '}';
                            my $m = Perlito5::Grammar::block($replace, 0);
                            if (!$m) {
                                die('syntax error')
                            }
                            $replace = Perlito5::Match::flat($m);
                            if ($modifiers =~ m!ee!) {
                                $replace = Perlito5::AST::Block::->new('sig' => undef, 'stmts' => [Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$replace])], 'bareword' => '', 'namespace' => '')])
                            }
                        }
                        else {
                            $replace = Perlito5::Match::flat($part2)
                        }
                        if ($m) {
                            $part2->{'to'} = $m->{'to'}
                        }
                        $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:s', 'arguments' => [$str_regex, $replace, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
                        return $part2
                    }
                    sub Perlito5::Grammar::String::qr_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        my $closing_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                        my $interpolate = 2;
                        $delimiter eq chr(39) && ($interpolate = 3);
                        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
                        $part1 || return $part1;
                        my $str_regex = $part1->{'capture'};
                        my $p = $part1->{'to'};
                        my $modifiers = '';
                        my $m = Perlito5::Grammar::ident($str, $p);
                        if ($m) {
                            $modifiers = Perlito5::Match::flat($m);
                            $part1->{'to'} = $m->{'to'}
                        }
                        $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:qr', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers)], 'namespace' => '');
                        return $part1
                    }
                    sub Perlito5::Grammar::String::qx_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
                        if ($m) {
                            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'qx', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
                        }
                        return $m
                    }
                    sub Perlito5::Grammar::String::glob_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
                        if (substr($str, $pos, 3) eq '<>>') {
                            return {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => '<>', 'arguments' => [], 'namespace' => '', 'bareword' => 1)], 'namespace' => '')}
                        }
                        if (substr($str, $pos, 1) eq '>') {
                            return {'str' => $str, 'from' => $pos, 'to' => $pos + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [], 'namespace' => '')}
                        }
                        my $p = $pos;
                        my $sigil = '::';
                        if (substr($str, $p, 1) eq '$') {
                            $sigil = '$';
                            $p++
                        }
                        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                        my $namespace = Perlito5::Match::flat($m_namespace);
                        $p = $m_namespace->{'to'};
                        my $m_name = Perlito5::Grammar::ident($str, $p);
                        if ($m_name && substr($str, $m_name->{'to'}, 1) eq '>') {
                            if ($sigil eq '::') {
                                return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($m_name), 'arguments' => [], 'namespace' => $namespace, 'bareword' => 1)], 'namespace' => '')}
                            }
                            return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Var::->new('sigil' => $sigil, 'name' => Perlito5::Match::flat($m_name), 'namespace' => $namespace)], 'namespace' => '')}
                        }
                        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1);
                        if ($m) {
                            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'glob', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
                        }
                        return $m
                    }
                    sub Perlito5::Grammar::String::tr_quote_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = substr($str, $pos - 1, 1);
                        my $open_delimiter = $delimiter;
                        my $closing_delimiter = $delimiter;
                        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
                        $part1 || return $part1;
                        my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
                        my $part2;
                        my $m;
                        my $p = $part1->{'to'};
                        if (exists($pair{$delimiter})) {
                            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                            $p = $m->{'to'};
                            $delimiter = substr($str, $p, 1);
                            my $open_delimiter = $delimiter;
                            $p++;
                            $closing_delimiter = $delimiter;
                            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
                            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                            $part2 || return $part2
                        }
                        else {
                            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
                            $part2 || return $part2
                        }
                        $p = $part2->{'to'};
                        my $modifiers = '';
                        $m = Perlito5::Grammar::ident($str, $p);
                        if ($m) {
                            $modifiers = Perlito5::Match::flat($m);
                            $part2->{'to'} = $m->{'to'}
                        }
                        $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:tr', 'arguments' => [$str_regex, Perlito5::Match::flat($part2), Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
                        return $part2
                    }
                    sub Perlito5::Grammar::String::apply_quote_flags {
                        my($c, $quote_flags) = @_;
                        length($c) || return $c;
                        if ($quote_flags->{'l'}) {
                            $c = lcfirst($c);
                            delete($quote_flags->{'l'})
                        }
                        if ($quote_flags->{'u'}) {
                            $c = ucfirst($c);
                            delete($quote_flags->{'u'})
                        }
                        $quote_flags->{'L'} && ($c = lc($c));
                        $quote_flags->{'U'} && ($c = uc($c));
                        $quote_flags->{'Q'} && ($c = quotemeta($c));
                        return $c
                    }
                    sub Perlito5::Grammar::String::string_interpolation_parse {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $open_delimiter = $_[2];
                        my $delimiter = $_[3];
                        my $interpolate = $_[4];
                        my $quote_flags = $_[5] || {};
                        my $interpolate_vars = ($interpolate == 1 || $interpolate == 2);
                        my $p = $pos;
                        my $balanced = $open_delimiter && exists($pair{$open_delimiter});
                        my @args;
                        my $buf = '';
                        while ($p < length($str) && substr($str, $p, length($delimiter)) ne $delimiter) {
                            my $c = substr($str, $p, 1);
                            my $c2 = substr($str, $p + 1, 1);
                            my $m;
                            my $more = '';
                            if ($balanced && $c eq chr(92) && ($c2 eq $open_delimiter || $c2 eq $delimiter)) {
                                $p++;
                                $c = $c2
                            }
                            elsif ($balanced && $c eq $open_delimiter) {
                                $buf .= $c;
                                $p++;
                                $m = string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate, $quote_flags);
                                $more = $delimiter
                            }
                            elsif ($interpolate_vars && ($c eq '$' || $c eq '@')) {
                                my $match = Perlito5::Grammar::String::double_quoted_var($str, $p, $delimiter, $interpolate);
                                if ($match) {
                                    my $ast = $match->{'capture'};
                                    if ($quote_flags->{'l'}) {
                                        $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lcfirst', 'arguments' => [$ast]);
                                        delete($quote_flags->{'l'})
                                    }
                                    if ($quote_flags->{'u'}) {
                                        $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ucfirst', 'arguments' => [$ast]);
                                        delete($quote_flags->{'u'})
                                    }
                                    $quote_flags->{'L'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lc', 'arguments' => [$ast]));
                                    $quote_flags->{'U'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'uc', 'arguments' => [$ast]));
                                    $quote_flags->{'Q'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'quotemeta', 'arguments' => [$ast]));
                                    $match->{'capture'} = $ast
                                }
                                $m = $match
                            }
                            elsif ($c eq chr(92)) {
                                if ($interpolate) {
                                    if ($c2 eq 'E') {
                                        my $flag_to_reset = $quote_flags->{'last_flag'};
                                        if ($flag_to_reset) {
                                            delete($quote_flags->{$flag_to_reset});
                                            delete($quote_flags->{'last_flag'})
                                        }
                                        else {
                                            $quote_flags = {}
                                        }
                                        $p += 1;
                                        $c = ''
                                    }
                                    elsif ($c2 eq 'L') {
                                        $quote_flags->{$c2} = 1;
                                        delete($quote_flags->{'U'});
                                        $quote_flags->{'last_flag'} = $c2;
                                        $p += 1;
                                        $c = ''
                                    }
                                    elsif ($c2 eq 'U') {
                                        $quote_flags->{$c2} = 1;
                                        delete($quote_flags->{'L'});
                                        $quote_flags->{'last_flag'} = $c2;
                                        $p += 1;
                                        $c = ''
                                    }
                                    elsif ($c2 eq 'Q') {
                                        $quote_flags->{$c2} = 1;
                                        $quote_flags->{'last_flag'} = $c2;
                                        $p += 1;
                                        $c = ''
                                    }
                                    elsif ($c2 eq 'l') {
                                        $quote_flags->{'u'} || ($quote_flags->{$c2} = 1);
                                        $p += 1;
                                        $c = ''
                                    }
                                    elsif ($c2 eq 'u') {
                                        $quote_flags->{'l'} || ($quote_flags->{$c2} = 1);
                                        $p += 1;
                                        $c = ''
                                    }
                                }
                                if ($c) {
                                    if ($interpolate == 2) {
                                        $m = {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => substr($str, $p, 2))}
                                    }
                                    elsif ($interpolate == 1) {
                                        $m = Perlito5::Grammar::String::double_quoted_unescape($str, $p)
                                    }
                                    else {
                                        $m = $c2 eq chr(92) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(92))} : $c2 eq chr(39) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(39))} : 0
                                    }
                                }
                            }
                            if ($m) {
                                my $obj = Perlito5::Match::flat($m);
                                if (ref($obj) eq 'Perlito5::AST::Buf') {
                                    $buf .= apply_quote_flags($obj->{'buf'}, $quote_flags);
                                    $obj = undef
                                }
                                if ($obj) {
                                    if (length($buf)) {
                                        push(@args, Perlito5::AST::Buf::->new('buf' => $buf));
                                        $buf = ''
                                    }
                                    push(@args, $obj)
                                }
                                $p = $m->{'to'};
                                $buf .= $more
                            }
                            else {
                                $p++;
                                if ($c eq chr(10) || $c eq chr(13)) {
                                    my $m = here_doc($str, $p);
                                    if ($p != $m->{'to'}) {
                                        $p = $m->{'to'}
                                    }
                                    else {
                                        $buf .= apply_quote_flags($c, $quote_flags)
                                    }
                                }
                                else {
                                    $buf .= apply_quote_flags($c, $quote_flags)
                                }
                            }
                        }
                        if (length($buf)) {
                            push(@args, Perlito5::AST::Buf::->new('buf' => $buf))
                        }
                        substr($str, $p, length($delimiter)) ne $delimiter && die('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF');
                        $p += length($delimiter);
                        my $ast;
                        if (!@args) {
                            $ast = Perlito5::AST::Buf::->new('buf' => '')
                        }
                        elsif (@args == 1) {
                            $ast = $args[0]
                        }
                        else {
                            $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<.>', 'arguments' => \@args)
                        }
                        return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => $ast}
                    }
                    our @Here_doc;
                    sub Perlito5::Grammar::String::here_doc_wanted {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter;
                        my $type = 'double_quote';
                        my $p = $pos;
                        if (substr($str, $p, 2) eq '<<') {
                            $p += 2;
                            my $quote = substr($str, $p, 1);
                            if ($quote eq chr(39) || $quote eq '"') {
                                $p += 1;
                                my $m = string_interpolation_parse($str, $p, $quote, $quote, 0);
                                if ($m) {
                                    $p = $m->{'to'};
                                    $delimiter = Perlito5::Match::flat($m)->{'buf'};
                                    $type = $quote eq chr(39) ? 'single_quote' : 'double_quote'
                                }
                            }
                            else {
                                $quote eq chr(92) && ($p += 1);
                                my $m = Perlito5::Grammar::ident($str, $p);
                                if ($m) {
                                    $p = $m->{'to'};
                                    $delimiter = Perlito5::Match::flat($m);
                                    $type = $quote eq chr(92) ? 'single_quote' : 'double_quote'
                                }
                                else {
                                    $Perlito5::WARNINGS && warn('Use of bare << to mean <<"" is deprecated');
                                    $delimiter = '';
                                    $type = 'double_quote'
                                }
                            }
                        }
                        if (!defined($delimiter)) {
                            return 0
                        }
                        my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
                        push(@Here_doc, [$type, $placeholder->{'arguments'}->[0]->{'arguments'}, $delimiter]);
                        return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['term', $placeholder]}
                    }
                    sub Perlito5::Grammar::String::newline {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m = $MATCH;
                                    if (!(chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                                        $MATCH = $m
                                    }
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m = $MATCH;
                                    if (!(chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                                        $MATCH = $m
                                    }
                                    1
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::String::here_doc {
                        my $str = $_[0];
                        my $pos = $_[1];
                        if (!@Here_doc) {
                            return {'str' => $str, 'from' => $pos, 'to' => $pos}
                        }
                        my $p = $pos;
                        my $here = shift(@Here_doc);
                        my $type = $here->[0];
                        my $result = $here->[1];
                        my $delimiter = $here->[2];
                        if ($type eq 'single_quote') {
                            while ($p < length($str)) {
                                if (substr($str, $p, length($delimiter)) eq $delimiter) {
                                    push(@{$result}, Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $p - $pos)));
                                    $p += length($delimiter);
                                    my $m = newline($str, $p);
                                    if ($p >= length($str) || $m) {
                                        $m && ($p = $m->{'to'});
                                        return {'str' => $str, 'from' => $pos, 'to' => $p - 1}
                                    }
                                }
                                while ($p < length($str) && (substr($str, $p, 1) ne chr(10) && substr($str, $p, 1) ne chr(13))) {
                                    $p++
                                }
                                while ($p < length($str) && (substr($str, $p, 1) eq chr(10) || substr($str, $p, 1) eq chr(13))) {
                                    $p++
                                }
                            }
                        }
                        else {
                            my $m;
                            if (substr($str, $p, length($delimiter)) eq $delimiter) {
                                $p += length($delimiter);
                                $m = newline($str, $p);
                                if ($p >= length($str) || $m) {
                                    push(@{$result}, Perlito5::AST::Buf::->new('buf' => ''));
                                    $m && ($p = $m->{'to'});
                                    return {'str' => $str, 'from' => $pos, 'to' => $p}
                                }
                            }
                            $m = string_interpolation_parse($str, $pos, '', chr(10) . $delimiter . chr(10), 1);
                            if ($m) {
                                push(@{$result}, Perlito5::Match::flat($m));
                                push(@{$result}, Perlito5::AST::Buf::->new('buf' => chr(10)));
                                $m->{'to'} = $m->{'to'} - 1;
                                return $m
                            }
                        }
                        die('Can' . chr(39) . 't find string terminator "' . $delimiter . '" anywhere before EOF')
                    }
                    sub Perlito5::Grammar::String::double_quoted_unescape {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $c2 = substr($str, $pos + 1, 1);
                        my $m;
                        if (exists($escape_sequence{$c2})) {
                            $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($escape_sequence{$c2}))}
                        }
                        elsif ($c2 eq 'c') {
                            my $c3 = ord(uc(substr($str, $pos + 2, 1))) - ord('A') + 1;
                            $c3 < 0 && ($c3 = 128 + $c3);
                            $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($c3))}
                        }
                        elsif ($c2 eq 'x') {
                            if (substr($str, $pos + 2, 1) eq '{') {
                                my $p = $pos + 3;
                                $p++
                                    while $p < length($str) && substr($str, $p, 1) ne '}';
                                my $hex_code = substr($str, $pos + 3, $p - $pos - 3);
                                $hex_code || ($hex_code = 0);
                                my $tmp = oct('0x' . $hex_code);
                                $m = {'str' => $str, 'from' => $pos, 'to' => $p + 1, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
                            }
                            else {
                                my $p = $pos + 2;
                                $hex{uc(substr($str, $p, 1))} && $p++;
                                $hex{uc(substr($str, $p, 1))} && $p++;
                                my $hex_code = substr($str, $pos + 2, $p - $pos - 2);
                                $hex_code || ($hex_code = 0);
                                my $tmp = oct('0x' . $hex_code);
                                $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
                            }
                        }
                        elsif (exists($octal{$c2})) {
                            my $p = $pos + 1;
                            $octal{substr($str, $p, 1)} && $p++;
                            $octal{substr($str, $p, 1)} && $p++;
                            $octal{substr($str, $p, 1)} && $p++;
                            my $oct_code = substr($str, $pos + 1, $p - $pos - 1);
                            my $tmp = oct($oct_code);
                            $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
                        }
                        elsif ($c2 eq 'N') {
                            die('TODO - ' . chr(92) . 'N{charname} not implemented; requires ' . chr(39) . 'use charnames' . chr(39))
                        }
                        else {
                            $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => $c2)}
                        }
                        return $m
                    }
                    sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
                        my $m_var = $_[0];
                        my $interpolate = $_[1];
                        my $str = $m_var->{'str'};
                        my $pos = $m_var->{'to'};
                        my $p = $pos;
                        my $m_index;
                        if (substr($str, $p, 3) eq '->[') {
                            $p += 3;
                            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
                            $m_index || die('syntax error');
                            my $exp = $m_index->{'capture'};
                            $p = $m_index->{'to'};
                            ($exp eq '*undef*' || substr($str, $p, 1) ne ']') && die('syntax error');
                            $p++;
                            $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<[ ]>', 'invocant' => $m_var->{'capture'}, 'arguments' => $exp);
                            $m_index->{'to'} = $p;
                            return double_quoted_var_with_subscript($m_index, $interpolate)
                        }
                        if (substr($str, $p, 3) eq '->{') {
                            $pos += 2;
                            $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
                            $m_index || die('syntax error');
                            $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<{ }>', 'invocant' => $m_var->{'capture'}, 'arguments' => Perlito5::Match::flat($m_index)->[2]->[0]);
                            return double_quoted_var_with_subscript($m_index, $interpolate)
                        }
                        if (substr($str, $p, 1) eq '[') {
                            if ($interpolate == 2) {
                                my $m = Perlito5::Grammar::Number::term_digit($str, $p + 1) || (substr($str, $p + 1, 1) eq '-' && Perlito5::Grammar::Number::term_digit($str, $p + 2)) || Perlito5::Grammar::Sigil::term_sigil($str, $p + 1);
                                $m || return $m_var;
                                substr($str, $m->{'to'}, 1) eq ']' || return $m_var
                            }
                            $p++;
                            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
                            if ($m_index) {
                                my $exp = $m_index->{'capture'};
                                $p = $m_index->{'to'};
                                if ($exp ne '*undef*' && substr($str, $p, 1) eq ']') {
                                    $p++;
                                    my $value = $m_var->{'capture'};
                                    if (ref($value) eq 'Perlito5::AST::Var') {
                                        $value->{'_real_sigil'} = '@'
                                    }
                                    $m_index->{'capture'} = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $exp);
                                    $m_index->{'to'} = $p;
                                    return double_quoted_var_with_subscript($m_index, $interpolate)
                                }
                            }
                        }
                        $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
                        if ($m_index) {
                            my $value = $m_var->{'capture'};
                            if (ref($value) eq 'Perlito5::AST::Var') {
                                $value->{'_real_sigil'} = '%'
                            }
                            $m_index->{'capture'} = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => Perlito5::Match::flat($m_index)->[2]->[0]);
                            return double_quoted_var_with_subscript($m_index, $interpolate)
                        }
                        return $m_var
                    }
                    sub Perlito5::Grammar::String::double_quoted_var {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $delimiter = $_[2];
                        my $interpolate = $_[3];
                        my $c = substr($str, $pos, 1);
                        if ($c eq '$' && substr($str, $pos + 1, 1) eq '{') {
                            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
                            $m || return $m;
                            my $var = Perlito5::Match::flat($m)->[1];
                            $m->{'capture'} = $var;
                            return $m
                        }
                        elsif ($c eq '$' && substr($str, $pos + 1, 1) eq '$' && !Perlito5::Grammar::word($str, $pos + 2)) {
                            return {'str' => $str, 'capture' => Perlito5::AST::Var::->new('name' => '$', 'sigil' => '$', 'namespace' => ''), 'from' => $pos, 'to' => $pos + 2}
                        }
                        elsif ($c eq '$' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
                            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
                            $m || return $m;
                            $m->{'capture'} = $m->{'capture'}->[1];
                            return double_quoted_var_with_subscript($m, $interpolate)
                        }
                        elsif ($c eq '@' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
                            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
                            $m || return $m;
                            $m->{'capture'} = $m->{'capture'}->[1];
                            $m = double_quoted_var_with_subscript($m, $interpolate);
                            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'join', 'arguments' => [Perlito5::AST::Var::->new('name' => '"', 'sigil' => '$', 'namespace' => ''), $m->{'capture'}], 'namespace' => '');
                            return $m
                        }
                        return 0
                    }
                    Perlito5::Grammar::Precedence::add_term(chr(39) => \&term_q_quote);
                    Perlito5::Grammar::Precedence::add_term('"' => \&term_qq_quote);
                    Perlito5::Grammar::Precedence::add_term('/' => \&term_m_quote);
                    Perlito5::Grammar::Precedence::add_term('<' => \&term_glob);
                    Perlito5::Grammar::Precedence::add_term('<<>>' => \&term_glob);
                    Perlito5::Grammar::Precedence::add_term('<<' => \&here_doc_wanted);
                    Perlito5::Grammar::Precedence::add_term('`' => \&term_qx);
                    Perlito5::Grammar::Precedence::add_term('m' => \&term_m_quote);
                    Perlito5::Grammar::Precedence::add_term('q' => \&term_q_quote);
                    Perlito5::Grammar::Precedence::add_term('qq' => \&term_qq_quote);
                    Perlito5::Grammar::Precedence::add_term('qw' => \&term_qw_quote);
                    Perlito5::Grammar::Precedence::add_term('qx' => \&term_qx);
                    Perlito5::Grammar::Precedence::add_term('qr' => \&term_qr_quote);
                    Perlito5::Grammar::Precedence::add_term('s' => \&term_s_quote);
                    Perlito5::Grammar::Precedence::add_term('tr' => \&term_tr_quote);
                    Perlito5::Grammar::Precedence::add_term('y' => \&term_tr_quote);
                    1
                }
            }
            {
                {
                    package main;
                    undef();
                    package Perlito5::Grammar::Sigil;
                    undef();
                    my %special_var = ('$_' => '', '$&' => '', '$`' => '', '$' . chr(39) => '', '$+' => '', '@+' => '', '%+' => '', '$.' => '', '$/' => '', '$|' => '', '$,' => '', '$' . chr(92) => '', '$"' => '', '$;' => '', '$%' => '', '$=' => '', '$-' => '', '@-' => '', '%-' => '', '$~' => '', '$^' => '', '$:' => '', '$?' => '', '$!' => '', '%!' => '', '$@' => '', '$$' => '', '$<' => '', '$>' => '', '$(' => '', '$)' => '', '$[' => '', '$]' => '', '@_' => '', '*_' => '', '*&' => '', '*`' => '', '*' . chr(39) => '', '*+' => '', '*.' => '', '*/' => '', '*|' => '', '*,' => '', '*' . chr(92) => '', '*"' => '', '*;' => '', '*%' => '', '*=' => '', '*-' => '', '*~' => '', '*^' => '', '*:' => '', '*?' => '', '*!' => '', '*@' => '', '*$' => '', '*<' => '', '*>' => '', '*(' => '', '*)' => '', '*[' => '', '*]' => '', '*_' => '', '**' => '', '*#' => '', '$#+' => '', '$#-' => '', '$#_' => '');
                    sub Perlito5::Grammar::Sigil::term_special_var {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $len = 0;
                        my $s = substr($str, $pos, 3);
                        if ($s eq '$#[') {
                            $len = 2
                        }
                        elsif (exists($special_var{$s})) {
                            $len = length($s)
                        }
                        else {
                            $s = substr($str, $pos, 2);
                            if (exists($special_var{$s})) {
                                $len = 2
                            }
                        }
                        if ($len) {
                            my $c0 = substr($str, $pos + $len - 1, 1);
                            my $c1 = substr($str, $pos + $len, 1);
                            if (($c0 eq '$' || $c0 eq '@' || $c0 eq '%' || $c0 eq '*' || $c0 eq '&') && ($c1 eq '$' || $c1 eq '@' || $c1 eq '%' || $c1 eq '*' || $c1 eq '&' || ($c1 ge 'a' && $c1 le 'z') || ($c1 ge 'A' && $c1 le 'Z') || ($c1 ge 0 && $c1 le 9))) {}
                            else {
                                return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['term', Perlito5::AST::Var::->new('sigil' => substr($s, 0, $len - 1), 'namespace' => $special_var{$s}, 'name' => substr($s, $len - 1, 1), '_namespace' => 'main')]}
                            }
                        }
                        return 0
                    }
                    my %sigil = ('$' => 1, '%' => 1, '@' => 1, '&' => 1, '*' => 1);
                    sub Perlito5::Grammar::Sigil::term_sigil {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $c1 = substr($str, $pos, 1);
                        exists($sigil{$c1}) || return ;
                        my $p = $pos + 1;
                        my $sigil = $c1;
                        if (substr($str, $pos, 2) eq '$#') {
                            $sigil = '$#';
                            $p++
                        }
                        my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                        $p = $m->{'to'};
                        $c1 = substr($str, $p, 1);
                        my $q = $p + 1;
                        if ($c1 eq '{') {
                            my $p = $q;
                            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
                            $p = $m->{'to'};
                            $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                            if ($m) {
                                my $namespace = Perlito5::Match::flat($m);
                                my $pos = $m->{'to'};
                                my $n = Perlito5::Grammar::var_name($str, $m->{'to'});
                                my $name;
                                if ($n) {
                                    $name = Perlito5::Match::flat($n);
                                    $pos = $n->{'to'}
                                }
                                if ($namespace || $name) {
                                    my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos);
                                    if (substr($str, $pos, 1) eq '{' || substr($str, $pos, 1) eq '[' || substr($str, $pos, 1) eq '}') {
                                        $m->{'capture'} = Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => $name);
                                        $m->{'to'} = $spc->{'to'};
                                        $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                                        $m->{'capture'} = ['term', $m->{'capture'}];
                                        $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{'to'});
                                        my $p = $spc->{'to'};
                                        if (substr($str, $p, 1) eq '}') {
                                            $m->{'to'} = $p + 1;
                                            return $m
                                        }
                                    }
                                }
                            }
                            my $caret = Perlito5::Grammar::caret_char($str, $p);
                            if ($caret) {
                                my $p = $caret->{'to'};
                                my $name = Perlito5::Match::flat($caret);
                                $m = Perlito5::Grammar::var_name($str, $p);
                                if ($m) {
                                    $name = $name . Perlito5::Match::flat($m);
                                    $p = $m->{'to'}
                                }
                                if (substr($str, $p, 1) eq '}') {
                                    $caret->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [Perlito5::AST::Buf::->new('buf' => $name)], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                                    $caret->{'to'} = $p + 1;
                                    return $caret
                                }
                            }
                            my $special = $sigil . substr($str, $p, 1);
                            if (exists($special_var{$special})) {
                                my $m = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
                                my $p2 = $m->{'to'};
                                my $c2 = substr($str, $p2, 1);
                                if ($c2 eq '}') {
                                    $m->{'to'} = $p2 + 1;
                                    $m->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => '', 'name' => substr($str, $p, 1), ($sigil eq '$#' ? ('_real_sigil' => '@') : ()), '_namespace' => 'main')];
                                    return $m
                                }
                            }
                            $m = Perlito5::Grammar::Expression::curly_parse($str, $p);
                            if ($m) {
                                my $p = $m->{'to'};
                                if (substr($str, $p, 1) eq '}') {
                                    $m->{'to'} = $m->{'to'} + 1;
                                    $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [$m->{'capture'}], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                                    return $m
                                }
                            }
                        }
                        my $caret = Perlito5::Grammar::caret_char($str, $p);
                        if ($caret) {
                            my $name = Perlito5::Match::flat($caret);
                            $caret->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [Perlito5::AST::Buf::->new('buf' => $name)], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                            return $caret
                        }
                        if ($c1 eq '$') {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
                            my $p2 = $m2->{'to'};
                            my $c2 = substr($str, $p2, 1);
                            if ($c2 ne ',' && $c2 ne ';') {
                                $m = term_sigil($str, $p);
                                if ($m) {
                                    $m->{'capture'} = ['term', Perlito5::AST::Apply::->new('arguments' => [$m->{'capture'}->[1]], 'code' => 'prefix:<' . $sigil . '>', 'namespace' => '')];
                                    return $m
                                }
                            }
                        }
                        $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                        if ($m) {
                            my $namespace = Perlito5::Match::flat($m);
                            my $n = Perlito5::Grammar::var_name($str, $m->{'to'});
                            if ($n) {
                                $n->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => Perlito5::Match::flat($n), ($sigil eq '$#' ? ('_real_sigil' => '@') : ()))];
                                return $n
                            }
                            if ($namespace) {
                                $m->{'capture'} = ['term', Perlito5::AST::Var::->new('sigil' => $sigil, 'namespace' => $namespace, 'name' => undef, ($sigil eq '$#' ? ('_real_sigil' => '@') : ()))];
                                return $m
                            }
                        }
                        return term_special_var($str, $pos)
                    }
                    Perlito5::Grammar::Precedence::add_term('$' => \&term_sigil);
                    Perlito5::Grammar::Precedence::add_term('@' => \&term_sigil);
                    Perlito5::Grammar::Precedence::add_term('%' => \&term_sigil);
                    Perlito5::Grammar::Precedence::add_term('&' => \&term_sigil);
                    Perlito5::Grammar::Precedence::add_term('*' => \&term_sigil);
                    1
                }
            }
            {
                {
                    package main;
                    package Perlito5::Grammar::Use;
                    undef();
                    undef();
                    use strict;
                    my %Perlito_internal_module = ('strict' => 'Perlito5X::strict', 'warnings' => 'Perlito5X::warnings', 'feature' => 'Perlito5X::feature', 'utf8' => 'Perlito5X::utf8', 'bytes' => 'Perlito5X::bytes', 'encoding' => 'Perlito5X::encoding', 'Carp' => 'Perlito5X::Carp', 'Exporter' => 'Perlito5X::Exporter', 'Data::Dumper' => 'Perlito5X::Dumper');
                    sub Perlito5::Grammar::Use::use_decl {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('use' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('no' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Use::version_string {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::val_version'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar::Number::val_version'}->{'capture'};
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::term_digit'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $version = $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'buf'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'int'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'num'};
                                    $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => $version);
                                    1
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Use::term_require {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('require' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = version_string($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'version_string'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $version = $MATCH->{'version_string'}->{'capture'};
                                    $version->{'is_version_string'} = 1;
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [$version])];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $module_name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                    my $filename = modulename_to_filename($module_name);
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => $filename)])];
                                    1
                                }))
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Use::stmt_use {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = use_decl($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'use_decl'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = version_string($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'version_string'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $version = $MATCH->{'version_string'}->{'capture'}->{'buf'};
                                    Perlito5::test_perl_version($version);
                                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => []);
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m = $MATCH;
                                    if (!(('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                        my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            if (exists($MATCH->{'Perlito5::Grammar::ident'})) {
                                                push(@{$MATCH->{'Perlito5::Grammar::ident'}}, $m2)
                                            }
                                            else {
                                                $MATCH->{'Perlito5::Grammar::ident'} = [$m2]
                                            }
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && (do {
                                    my $m = $MATCH;
                                    if (!((do {
                                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }) && (do {
                                        my $m2 = version_string($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            if (exists($MATCH->{'version_string'})) {
                                                push(@{$MATCH->{'version_string'}}, $m2)
                                            }
                                            else {
                                                $MATCH->{'version_string'} = [$m2]
                                            }
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }) && (do {
                                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) {
                                        $MATCH = $m
                                    }
                                    1
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $version = $MATCH->{'version_string'}->[0]->{'capture'}->{'buf'};
                                    my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                                    if ($list eq '*undef*') {
                                        $list = undef
                                    }
                                    else {
                                        my $m = $MATCH->{'Perlito5::Grammar::Expression::list_parse'};
                                        my $list_code = substr($str, $m->{'from'}, $m->{'to'} - $m->{'from'});
                                        my @list = eval($list_code);
                                        $list = \@list
                                    }
                                    my $full_ident = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                                    $Perlito5::PACKAGES->{$full_ident} = 1;
                                    my $use_decl = Perlito5::Match::flat($MATCH->{'use_decl'});
                                    if ($use_decl eq 'use' && $full_ident eq 'vars' && $list) {
                                        my $code = 'our (' . join(', ', @{$list}) . ')';
                                        my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                        !$m && die('not a valid variable name: ' . join(${'"'}, @{$list}));
                                        $MATCH->{'capture'} = $m->{'capture'}
                                    }
                                    elsif ($full_ident eq 'strict') {
                                        $Perlito5::STRICT = ($use_decl eq 'no' ? 0 : 1);
                                        my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                                        $MATCH->{'capture'} = $ast
                                    }
                                    elsif ($use_decl eq 'use' && $full_ident eq 'constant' && $list) {
                                        my @ast;
                                        my $name = shift(@{$list});
                                        if (ref($name) eq 'HASH') {
                                            for my $key (sort {
                                                $a cmp $b
                                            } keys(%{$name})) {
                                                my $code = 'sub ' . $key . ' () { ' . Perlito5::Dumper::_dumper($name->{$key}) . ' }';
                                                my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                                !$m && die('not a valid constant: ' . join(${'"'}, @{$list}));
                                                push(@ast, $m->{'capture'})
                                            }
                                        }
                                        else {
                                            my $code = 'sub ' . $name . ' () { (' . join(', ', map {
                                                Perlito5::Dumper::_dumper($_)
                                            } @{$list}) . ') }';
                                            my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                            !$m && die('not a valid constant: ' . join(${'"'}, @{$list}));
                                            push(@ast, $m->{'capture'})
                                        }
                                        $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => \@ast)
                                    }
                                    else {
                                        my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                                        $MATCH->{'capture'} = parse_time_eval($ast)
                                    }
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'str'} = $str;
                                    die('Syntax error');
                                    1
                                })
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Use::parse_time_eval {
                        my $ast = shift;
                        my $module_name = $ast->mod();
                        my $use_or_not = $ast->code();
                        my $arguments = $ast->{'arguments'};
                        my $skip_import = defined($arguments) && @{$arguments} == 0;
                        defined($arguments) || ($arguments = []);
                        my $comp_units = [];
                        expand_use($comp_units, $ast);
                        if ($Perlito5::EXPAND_USE) {
                            my $current_module_name = $Perlito5::PKG_NAME;
                            my $filename = modulename_to_filename($module_name);
                            require($filename);
                            if (!$skip_import) {
                                if ($use_or_not eq 'use') {
                                    if (defined(&{$module_name . '::import'})) {
                                        unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                                        eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->import(@$arguments); 1') or die(${'@'});
                                        shift(@{$Perlito5::CALLER})
                                    }
                                }
                                elsif ($use_or_not eq 'no') {
                                    if (defined(&{$module_name . '::unimport'})) {
                                        unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                                        eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->unimport(@$arguments); 1') or die(${'@'});
                                        shift(@{$Perlito5::CALLER})
                                    }
                                }
                            }
                        }
                        if (@{$comp_units}) {
                            return Perlito5::AST::Block::->new('stmts' => $comp_units)
                        }
                        else {
                            return Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
                        }
                    }
                    sub Perlito5::Grammar::Use::emit_time_eval {
                        my $ast = shift;
                        if ($ast->mod() eq 'strict') {
                            if ($ast->code() eq 'use') {
                                strict::->import()
                            }
                            elsif ($ast->code() eq 'no') {
                                strict::->unimport()
                            }
                        }
                    }
                    sub Perlito5::Grammar::Use::modulename_to_filename {
                        my $s = shift;
                        exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
                        $s =~ s!::!/!g;
                        return $s . '.pm'
                    }
                    sub Perlito5::Grammar::Use::filename_lookup {
                        my $filename = shift;
                        if (exists($INC{$filename})) {
                            $INC{$filename} && return 'done';
                            die('Compilation failed in require')
                        }
                        for my $prefix (@INC, '.') {
                            my $realfilename = $prefix . '/' . $filename;
                            if (-f $realfilename) {
                                $INC{$filename} = $realfilename;
                                return 'todo'
                            }
                        }
                        die('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').')
                    }
                    sub Perlito5::Grammar::Use::expand_use {
                        my $comp_units = shift;
                        my $stmt = shift;
                        my $module_name = $stmt->mod();
                        my $filename = modulename_to_filename($module_name);
                        filename_lookup($filename) eq 'done' && return ;
                        local $Perlito5::FILE_NAME = $filename;
                        local $Perlito5::LINE_NUMBER = 1;
                        my $realfilename = $INC{$filename};
                        open(FILE, '<', $realfilename) or die('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
                        local $/ = undef;
                        my $source = <FILE>;
                        close(FILE);
                        my $m = Perlito5::Grammar::exp_stmts($source, 0);
                        $m->{'to'} != length($source) && die('Syntax Error near ', $m->{'to'});
                        if ($m->{'to'} != length($source)) {
                            my $pos = $m->{'to'} - 10;
                            $pos < 0 && ($pos = 0);
                            print('* near: ', substr($source, $pos, 20), chr(10));
                            print('* filename: ' . $realfilename . chr(10));
                            die('Syntax Error near ', $m->{'to'})
                        }
                        if ($ENV{'PERLITO5DEV'}) {
                            push(@{$comp_units}, Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m)));
                            return 
                        }
                        push(@{$comp_units}, @{add_comp_unit([Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m))])});
                        return 
                    }
                    sub Perlito5::Grammar::Use::add_comp_unit {
                        my $parse = shift;
                        my $comp_units = [];
                        for my $comp_unit (@{$parse}) {
                            if (defined($comp_unit)) {
                                if ($comp_unit->isa('Perlito5::AST::Use')) {
                                    expand_use($comp_units, $comp_unit)
                                }
                                elsif ($comp_unit->isa('Perlito5::AST::CompUnit')) {
                                    for my $stmt (@{$comp_unit->body()}) {
                                        if ($stmt->isa('Perlito5::AST::Use')) {
                                            expand_use($comp_units, $stmt)
                                        }
                                    }
                                }
                                push(@{$comp_units}, $comp_unit)
                            }
                        }
                        return $comp_units
                    }
                    sub Perlito5::Grammar::Use::require {
                        my $filename = shift;
                        filename_lookup($filename) eq 'done' && return ;
                        my $result = do($filename);
                        if (${'@'}) {
                            $INC{$filename} = undef;
                            die(${'@'})
                        }
                        elsif (!$result) {
                            delete($INC{$filename});
                            ${'@'} && warn(${'@'});
                            die($filename . ' did not return true value')
                        }
                        else {
                            return $result
                        }
                    }
                    sub Perlito5::Grammar::Use::do_file {
                        my $filename = shift;
                        eval {
                            filename_lookup($filename);
                            1
                        } or do {
                            $INC{$filename} = undef;
                            ${'@'} = '';
                            ${'!'} = 'No such file or directory';
                            return 'undef'
                        };
                        my $realfilename = $INC{$filename};
                        open(FILE, '<', $realfilename) or die('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
                        local $/ = undef;
                        my $source = <FILE>;
                        close(FILE);
                        return $source
                    }
                    Perlito5::Grammar::Statement::add_statement('no' => \&stmt_use);
                    Perlito5::Grammar::Statement::add_statement('use' => \&stmt_use);
                    Perlito5::Grammar::Precedence::add_term('require' => \&term_require);
                    1
                }
            }
            {
                {
                    package main;
                    package Perlito5::Grammar::Block;
                    undef();
                    {
                        {
                            package main;
                            package Perlito5::Grammar::Scope;
                            use strict;
                            our %Special_var = ('ARGV' => 1, 'INC' => 1, 'ENV' => 1, 'SIG' => 1, '_' => 1);
                            sub Perlito5::Grammar::Scope::new {
                                return {'block' => []}
                            }
                            sub Perlito5::Grammar::Scope::new_base_scope {
                                return {'block' => []}
                            }
                            sub Perlito5::Grammar::Scope::create_new_compile_time_scope {
                                my $new_scope = {'block' => []};
                                push(@{$Perlito5::SCOPE->{'block'}}, $new_scope);
                                $Perlito5::SCOPE_DEPTH++;
                                $Perlito5::SCOPE = $new_scope
                            }
                            sub Perlito5::Grammar::Scope::end_compile_time_scope {
                                my $pos = 0;
                                $Perlito5::SCOPE_DEPTH--;
                                $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
                                while ($Perlito5::SCOPE_DEPTH > $pos) {
                                    $pos++;
                                    $Perlito5::SCOPE = $Perlito5::SCOPE->{'block'}->[-1]
                                }
                            }
                            sub Perlito5::Grammar::Scope::lookup_variable {
                                my $var = shift;
                                my $scope = shift() // $Perlito5::BASE_SCOPE;
                                $var->{'namespace'} && return $var;
                                $var->{'_decl'} && return $var;
                                my $look = lookup_variable_inner($var, $scope, 0);
                                $look && return $look;
                                my $c = substr($var->{'name'}, 0, 1);
                                if ($Special_var{$var->{'name'}} || $c lt 'A' || ($c gt 'Z' && $c lt 'a') || $c gt 'z') {
                                    $var->{'_decl'} = 'global';
                                    $var->{'_namespace'} = 'main';
                                    return $var
                                }
                                if ($var->{'sigil'} eq '$' && ($var->{'name'} eq 'a' || $var->{'name'} eq 'b')) {
                                    if (!$var->{'_real_sigil'}) {
                                        $var->{'_decl'} = 'global';
                                        $var->{'_namespace'} = $Perlito5::PKG_NAME;
                                        return $var
                                    }
                                }
                                return 
                            }
                            sub Perlito5::Grammar::Scope::lookup_variable_inner {
                                my($var, $scope, $depth) = @_;
                                $depth > $Perlito5::SCOPE_DEPTH && return ;
                                my $block = $scope->{'block'};
                                if (@{$block} && ref($block->[-1]) eq 'HASH' && $block->[-1]->{'block'}) {
                                    my $look = lookup_variable_inner($var, $block->[-1], $depth + 1);
                                    $look && return $look
                                }
                                for my $item (reverse(@{$block})) {
                                    if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'} && $item->{'_decl'} ne 'global' && $item->{'name'} eq $var->{'name'}) {
                                        my $sigil = $var->{'_real_sigil'} || $var->{'sigil'};
                                        my $item_sigil = $item->{'_real_sigil'} || $item->{'sigil'};
                                        if ($sigil eq $item_sigil) {
                                            return $item
                                        }
                                    }
                                }
                                return 
                            }
                            sub Perlito5::Grammar::Scope::check_variable_declarations {
                                for my $item (@Perlito5::SCOPE_STMT) {
                                    if (ref($item) eq 'Perlito5::AST::Var') {
                                        my $var = $item;
                                        my $look = lookup_variable($var);
                                        if ($look) {
                                            $look->{'_id'} && ($var->{'_id'} = $look->{'_id'});
                                            $look->{'_decl'} && ($var->{'_decl'} = $look->{'_decl'});
                                            $look->{'_namespace'} && ($var->{'_namespace'} = $look->{'_namespace'})
                                        }
                                        else {
                                            if ($Perlito5::STRICT) {
                                                my $sigil = $var->{'_real_sigil'} || $var->{'sigil'};
                                                if ($sigil ne '*' && $sigil ne '&') {
                                                    die('Global symbol "' . $sigil . $var->{'name'} . '"' . ' requires explicit package name' . ' at ' . $Perlito5::FILE_NAME)
                                                }
                                            }
                                            $var->{'_decl'} = 'global';
                                            $var->{'_namespace'} = $Perlito5::PKG_NAME
                                        }
                                        if ($ENV{'PERLITO5DEV'}) {
                                            my $compiletime_name = ($var->{'_real_sigil'} || $var->{'sigil'}) . ($var->{'namespace'} || $var->{'_namespace'} || 'C_') . '::' . $var->{'name'} . ($var->{'_decl'} eq 'global' ? '' : '_' . $var->{'_id'});
                                            $Perlito5::GLOBAL->{$compiletime_name} = {'value' => undef, 'ast' => $var}
                                        }
                                    }
                                }
                                push(@{$Perlito5::SCOPE->{'block'}}, @Perlito5::SCOPE_STMT);
                                @Perlito5::SCOPE_STMT = ()
                            }
                            sub Perlito5::Grammar::Scope::get_snapshot {
                                my @result;
                                my $scope = shift() // $Perlito5::BASE_SCOPE;
                                my $block = $scope->{'block'};
                                if (@{$block} && ref($block->[-1]) eq 'HASH' && $block->[-1]->{'block'}) {
                                    my $look = get_snapshot($block->[-1]);
                                    unshift(@result, @{$look->{'block'}})
                                }
                                for my $item (@{$block}) {
                                    if (ref($item) eq 'Perlito5::AST::Var' && $item->{'_decl'}) {
                                        unshift(@result, $item)
                                    }
                                }
                                return {'block' => \@result}
                            }
                            1
                        }
                    }
                    use strict;
                    our %Named_block = ('BEGIN' => 1, 'UNITCHECK' => 1, 'CHECK' => 1, 'INIT' => 1, 'END' => 1);
                    sub Perlito5::Grammar::Block::block {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                        $pos = $m->{'to'};
                        if (substr($str, $pos, 1) ne '{') {
                            return 
                        }
                        $pos++;
                        Perlito5::Grammar::Scope::check_variable_declarations();
                        Perlito5::Grammar::Scope::create_new_compile_time_scope();
                        $m = Perlito5::Grammar::exp_stmts($str, $pos);
                        if (!$m) {
                            die('syntax error')
                        }
                        $pos = $m->{'to'};
                        my $capture = Perlito5::Match::flat($m);
                        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                        $pos = $m->{'to'};
                        if (substr($str, $pos, 1) ne '}') {
                            die('syntax error')
                        }
                        $m->{'to'} = $pos + 1;
                        $m->{'capture'} = Perlito5::AST::Block::->new('stmts' => $capture, 'sig' => undef);
                        Perlito5::Grammar::Scope::end_compile_time_scope();
                        return $m
                    }
                    sub Perlito5::Grammar::Block::eval_begin_block {
                        local ${'@'};
                        my $code = 'package ' . $Perlito5::PKG_NAME . ';' . chr(10) . $_[0];
                        eval(Perlito5::CompileTime::Dumper::generate_eval_string('{ ' . $code . ' }; 1')) or die('Error in BEGIN block: ' . ${'@'})
                    }
                    sub Perlito5::Grammar::Block::opt_continue_block {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('continue' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                                    my $m2 = block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'block'});
                                    $MATCH->{'capture'}->{'is_continue'} = 1;
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => [], 'sig' => undef);
                                    1
                                })
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Block::anon_block {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $p = $pos;
                        local $Perlito5::BLOCK_HAS_SEMICOLON;
                        my $m = Perlito5::Grammar::block($str, $p);
                        !$m && return ;
                        $p = $m->{'to'};
                        my $block = Perlito5::Match::flat($m);
                        $m = Perlito5::Grammar::opt_continue_block($str, $p);
                        $p = $m->{'to'};
                        my $continue = Perlito5::Match::flat($m);
                        my $v = $block;
                        !$continue->{'is_continue'} && !$Perlito5::BLOCK_HAS_SEMICOLON && ($v = Perlito5::Grammar::Expression::block_or_hash($v));
                        $m->{'capture'} = $v;
                        if ($continue->{'is_continue'}) {
                            $m->{'capture'}->{'continue'} = $continue
                        }
                        return $m
                    }
                    sub Perlito5::Grammar::Block::special_named_block {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $p = $pos;
                        my $block_name;
                        my $m_name = Perlito5::Grammar::ident($str, $p);
                        !$m_name && return ;
                        $p = $m_name->{'to'};
                        $block_name = Perlito5::Match::flat($m_name);
                        my $ws = Perlito5::Grammar::Space::opt_ws($str, $p);
                        $p = $ws->{'to'};
                        my $block_start = $p;
                        my $m = Perlito5::Grammar::block($str, $p);
                        !$m && return ;
                        $p = $m->{'to'};
                        my $block = Perlito5::Match::flat($m);
                        my $compile_block = $Perlito5::SCOPE->{'block'}->[-1];
                        $compile_block->{'type'} = 'sub';
                        $compile_block->{'name'} = $block_name;
                        if ($block_name eq 'BEGIN') {
                            local $Perlito5::PHASE = 'BEGIN';
                            eval_begin_block(substr($str, $block_start, $m->{'to'} - $block_start));
                            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
                        }
                        else {
                            $m->{'capture'} = $block;
                            $m->{'capture'}->{'name'} = $block_name
                        }
                        return $m
                    }
                    sub Perlito5::Grammar::Block::named_sub_def {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::optional_namespace_before_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Block::prototype_'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Statement::statement_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    die('Illegal declaration of subroutine ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'}), chr(39));
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'_tmp'} = undef;
                                    1
                                })
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::ident'});
                            my $sig = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::prototype_'});
                            $sig eq '*undef*' && ($sig = undef);
                            my $attributes = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'});
                            my($proto) = grep {
                                $_->[0] eq 'prototype'
                            } @{$attributes};
                            if ($proto) {
                                $attributes = [grep {
                                    $_->[0] ne 'prototype'
                                } @{$attributes}];
                                $sig = $proto->[1]
                            }
                            my $namespace = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::optional_namespace_before_ident'});
                            if ($name) {
                                if (!$namespace) {
                                    $namespace = $name eq '_' ? 'main' : $Perlito5::PKG_NAME
                                }
                                my $full_name = $namespace . '::' . $name;
                                $Perlito5::PROTO->{$full_name} = $sig;
                                if ($MATCH->{'_tmp'}) {
                                    my $block = $Perlito5::SCOPE->{'block'}->[-1];
                                    $block->{'type'} = 'sub';
                                    $block->{'name'} = $full_name
                                }
                            }
                            my $sub = Perlito5::AST::Sub::->new('name' => $name, 'namespace' => $namespace, 'sig' => $sig, 'block' => $MATCH->{'_tmp'}, 'attributes' => $attributes);
                            if ($ENV{'PERLITO5DEV'}) {
                                if ($name) {
                                    my $full_name = $namespace . '::' . $name;
                                    $Perlito5::GLOBAL->{$full_name} = $sub;
                                    $sub = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
                                }
                            }
                            $MATCH->{'capture'} = $sub;
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Block::named_sub {
                        my $str = $_[0];
                        my $pos = $_[1];
                        substr($str, $pos, 3) eq 'sub' || return ;
                        my $ws = Perlito5::Grammar::Space::ws($str, $pos + 3);
                        $ws || return ;
                        my $p = $ws->{'to'};
                        my $m_name = Perlito5::Grammar::ident($str, $p);
                        $m_name || return ;
                        my $block_name = Perlito5::Match::flat($m_name);
                        if (exists($Named_block{$block_name})) {
                            return Perlito5::Grammar::Block::special_named_block($str, $p)
                        }
                        return Perlito5::Grammar::Block::named_sub_def($str, $p)
                    }
                    sub Perlito5::Grammar::Block::term_anon_sub {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('sub' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Block::anon_sub_def'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::anon_sub_def'})];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Block::term_do {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('do' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'})])];
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Block::args_sig {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while ((do {
                                my $pos1 = $MATCH->{'to'};
                                (do {
                                    (';' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    (chr(92) eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('[' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    (']' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('@' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('%' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                })
                            }) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Block::prototype_ {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = '_';
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = args_sig($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'args_sig'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = '' . Perlito5::Match::flat($MATCH->{'args_sig'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = '*undef*';
                                    1
                                })
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Block::anon_sub_def {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = prototype_($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'prototype_'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $sig = Perlito5::Match::flat($MATCH->{'prototype_'});
                            $sig eq '*undef*' && ($sig = undef);
                            my $attributes = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute::opt_attribute'});
                            my($proto) = grep {
                                $_->[0] eq 'prototype'
                            } @{$attributes};
                            if ($proto) {
                                $attributes = [grep {
                                    $_->[0] ne 'prototype'
                                } @{$attributes}];
                                $sig = $proto->[1]
                            }
                            $MATCH->{'capture'} = Perlito5::AST::Sub::->new('name' => undef, 'namespace' => undef, 'sig' => $sig, 'block' => Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::block'}), 'attributes' => $attributes);
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    Perlito5::Grammar::Precedence::add_term('do' => \&term_do);
                    Perlito5::Grammar::Precedence::add_term('sub' => \&term_anon_sub);
                    Perlito5::Grammar::Statement::add_statement('{' => \&anon_block);
                    Perlito5::Grammar::Statement::add_statement('sub' => \&named_sub);
                    Perlito5::Grammar::Statement::add_statement($_ => \&special_named_block)
                        for keys(%Named_block);
                    1
                }
            }
            {
                {
                    package main;
                    package Perlito5::Grammar::Space;
                    undef();
                    my %line_index;
                    sub Perlito5::Grammar::Space::count_line {
                        my $pos = $_[0];
                        $pos < $line_index{$Perlito5::FILE_NAME} && return ;
                        $line_index{$Perlito5::FILE_NAME} = $pos + 1;
                        $Perlito5::LINE_NUMBER++
                    }
                    my %space = ('#' => sub {
                        my $m = Perlito5::Grammar::Space::to_eol($_[0], $_[1]);
                        $m->{'to'}
                    }, chr(9) => sub {
                        $_[1]
                    }, chr(10) => sub {
                        my $str = $_[0];
                        my $pos = $_[1];
                        count_line($pos);
                        substr($str, $pos, 1) eq chr(13) && $pos++;
                        my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
                        $m->{'to'}
                    }, chr(12) => sub {
                        $_[1]
                    }, chr(13) => sub {
                        my $str = $_[0];
                        my $pos = $_[1];
                        if (substr($str, $pos, 1) eq chr(10)) {
                            count_line($pos);
                            $pos++
                        }
                        my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
                        $m->{'to'}
                    }, chr(32) => sub {
                        $_[1]
                    });
                    sub Perlito5::Grammar::Space::term_space {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $p = $pos;
                        while (exists($space{substr($str, $p, 1)})) {
                            $p = $space{substr($str, $p, 1)}->($str, $p + 1)
                        }
                        (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
                        return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['space', ' ']}
                    }
                    sub Perlito5::Grammar::Space::term_end {
                        my $str = $_[0];
                        my $p = $_[1];
                        my $is_data = 0;
                        if (substr($str, $_[1], 7) eq '__END__' && $Perlito5::PKG_NAME eq 'main') {
                            $p = $p + 7;
                            $is_data = 1
                        }
                        elsif (substr($str, $_[1], 8) eq '__DATA__') {
                            $p = $p + 8;
                            $is_data = 1
                        }
                        my $m = Perlito5::Grammar::Space::to_eol($str, $p);
                        $p = $m->{'to'};
                        if (substr($str, $p, 1) eq chr(10)) {
                            count_line($p);
                            $p++;
                            substr($str, $p, 1) eq chr(13) && $p++
                        }
                        elsif (substr($str, $p, 1) eq chr(13)) {
                            $p++;
                            if (substr($str, $p, 1) eq chr(10)) {
                                count_line($p);
                                $p++
                            }
                        }
                        if ($is_data) {
                            $Perlito5::DATA_SECTION{$Perlito5::PKG_NAME} = substr($_[0], $p)
                        }
                        return {'str' => $str, 'from' => $_[1], 'to' => length($_[0]), 'capture' => ['space', ' ']}
                    }
                    Perlito5::Grammar::Precedence::add_term('#' => \&term_space);
                    Perlito5::Grammar::Precedence::add_term(chr(9) => \&term_space);
                    Perlito5::Grammar::Precedence::add_term(chr(10) => \&term_space);
                    Perlito5::Grammar::Precedence::add_term(chr(12) => \&term_space);
                    Perlito5::Grammar::Precedence::add_term(chr(13) => \&term_space);
                    Perlito5::Grammar::Precedence::add_term(chr(32) => \&term_space);
                    Perlito5::Grammar::Precedence::add_term('__END__' => \&term_end);
                    Perlito5::Grammar::Precedence::add_term('__DATA__' => \&term_end);
                    sub Perlito5::Grammar::Space::to_eol {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while (((do {
                                my $tmp = $MATCH;
                                $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                my $res = (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                });
                                $MATCH = $tmp;
                                $res ? 0 : 1
                            }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Space::pod_pod_begin {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && ('=cut' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Space::pod_begin {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && ('=end' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = pod_begin($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Space::start_of_line {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = Perlito5::Grammar::String::here_doc($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('=' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (('pod' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                            my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('head' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                            my $m2 = pod_pod_begin($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('begin' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'})) && (do {
                                            my $m2 = pod_begin($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('for' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                            my $m2 = pod_begin($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('encoding' eq substr($str, $MATCH->{'to'}, 8) && ($MATCH->{'to'} = 8 + $MATCH->{'to'})) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('cut' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'})) && (do {
                                            my $m2 = to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    })
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && ('line' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            (' ' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (chr(9) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && (do {
                                    my $m2 = to_eol($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $Perlito5::LINE_NUMBER = 0 + Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::digits'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                1
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Space::ws {
                        my $str = shift;
                        my $pos = shift;
                        my $p = $pos;
                        while (exists($space{substr($str, $p, 1)})) {
                            $p = $space{substr($str, $p, 1)}->($str, $p + 1)
                        }
                        (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
                        if ($p == $pos) {
                            return 0
                        }
                        return {'str' => $str, 'from' => $pos, 'to' => $p}
                    }
                    sub Perlito5::Grammar::Space::opt_ws {
                        my $str = shift;
                        my $pos = shift;
                        my $p = $pos;
                        while (exists($space{substr($str, $p, 1)})) {
                            $p = $space{substr($str, $p, 1)}->($str, $p + 1)
                        }
                        (substr($str, $p, 7) eq '__END__' || substr($str, $p, 8) eq '__DATA__') && return term_end($str, $p);
                        return {'str' => $str, 'from' => $pos, 'to' => $p}
                    }
                    1
                }
            }
            {
                {
                    package main;
                    package Perlito5::Grammar::Print;
                    use strict;
                    our %Print = ('print' => 1, 'printf' => 1, 'say' => 1, 'exec' => 1, 'system' => 1);
                    sub Perlito5::Grammar::Print::print_decl {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('printf' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('print' eq substr($str, $MATCH->{'to'}, 5) && ($MATCH->{'to'} = 5 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('say' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('exec' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('system' eq substr($str, $MATCH->{'to'}, 6) && ($MATCH->{'to'} = 6 + $MATCH->{'to'}))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Print::the_object {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 1 : 0
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 0 : 1
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('{' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 1 : 0
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Block::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Block::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block::block'});
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = typeglob($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'typeglob'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                    my $res = ('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                    $MATCH = $tmp;
                                    $res ? 0 : 1
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'typeglob'});
                                    1
                                }))
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $pos = $MATCH->{'to'};
                            my $m = Perlito5::Grammar::Space::ws($MATCH->{'str'}, $pos);
                            $m && ($pos = $m->{'to'});
                            my $s = substr($MATCH->{'str'}, $pos, 1);
                            my $s2 = substr($MATCH->{'str'}, $pos, 2);
                            if ($s eq ',' || $s eq '?' || $s2 eq '->' || $s eq '[' || $s eq '{') {
                                return 
                            }
                            if ($s eq '+') {
                                my $m = Perlito5::Grammar::Space::ws($MATCH->{'str'}, $pos + 1);
                                if ($m) {
                                    return 
                                }
                            }
                            else {
                                my $m = Perlito5::Grammar::Precedence::op_parse($MATCH->{'str'}, $pos, 1);
                                my $next_op = $m ? Perlito5::Match::flat($m)->[1] : '';
                                my $is_infix = Perlito5::Grammar::Precedence::is_fixity_type('infix', $next_op);
                                $is_infix && return 
                            }
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Print::typeglob {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $p = $pos;
                        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
                        my $namespace = Perlito5::Match::flat($m_namespace);
                        $p = $m_namespace->{'to'};
                        my $m_name = Perlito5::Grammar::ident($str, $p);
                        if (!$m_name) {
                            if ($namespace) {
                                $m_namespace->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace);
                                return $m_namespace
                            }
                            return 
                        }
                        my $name = Perlito5::Match::flat($m_name);
                        $p = $m_name->{'to'};
                        if (substr($str, $p, 2) eq '::') {
                            $m_name->{'to'} = $p + 2;
                            $m_name->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $namespace . '::' . $name);
                            return $m_name
                        }
                        my $effective_name = ($namespace || $Perlito5::PKG_NAME) . '::' . $name;
                        if (exists($Perlito5::PROTO->{$effective_name}) || exists(&{$effective_name})) {
                            return 
                        }
                        if ((!$namespace || $namespace eq 'CORE') && exists($Perlito5::CORE_PROTO->{'CORE::' . $name})) {
                            return 
                        }
                        my $full_name = $name;
                        $namespace && ($full_name = $namespace . '::' . $name);
                        $m_name->{'capture'} = Perlito5::AST::Var::->new('sigil' => '::', 'name' => '', 'namespace' => $full_name);
                        return $m_name
                    }
                    sub Perlito5::Grammar::Print::print_ast {
                        my($decl, $the_object, $expr) = @_;
                        Perlito5::AST::Apply::->new('namespace' => '', 'code' => $decl, 'special_arg' => $the_object, 'arguments' => $expr)
                    }
                    sub Perlito5::Grammar::Print::term_print {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = print_decl($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'print_decl'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'_scope'} = $#Perlito5::SCOPE_STMT;
                                    1
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = the_object($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'the_object'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $#Perlito5::SCOPE_STMT = $MATCH->{'_scope'};
                                            return ;
                                            1
                                        })
                                    })
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                                    !ref($list) && return ;
                                    $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'_scope'} = $#Perlito5::SCOPE_STMT;
                                    1
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = the_object($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'the_object'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $#Perlito5::SCOPE_STMT = $MATCH->{'_scope'};
                                            return ;
                                            1
                                        })
                                    })
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                                    !ref($list) && return ;
                                    $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                                    1
                                }))
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    Perlito5::Grammar::Precedence::add_term('print' => \&term_print);
                    Perlito5::Grammar::Precedence::add_term('printf' => \&term_print);
                    Perlito5::Grammar::Precedence::add_term('say' => \&term_print);
                    Perlito5::Grammar::Precedence::add_term('exec' => \&term_print);
                    Perlito5::Grammar::Precedence::add_term('system' => \&term_print);
                    1
                }
            }
            {
                {
                    package main;
                    package Perlito5::Grammar::Map;
                    use strict;
                    sub Perlito5::Grammar::Map::map_or_grep {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('map' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('grep' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'}))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Map::term_map_or_grep {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = map_or_grep($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'map_or_grep'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg' => $MATCH->{'Perlito5::Grammar::block'}->{'capture'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg' => $MATCH->{'Perlito5::Grammar::block'}->{'capture'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                    1
                                }))
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Map::non_core_ident {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                            ($Perlito5::CORE_PROTO->{$name} || $Perlito5::CORE_PROTO->{'CORE::' . $name}) && return ;
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Map::term_sort {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('sort' eq substr($str, $MATCH->{'to'}, 4) && ($MATCH->{'to'} = 4 + $MATCH->{'to'})) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('(' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Map::non_core_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Map::non_core_ident'});
                                            $MATCH->{'_tmp'} = $name;
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'_tmp'} = $MATCH->{'Perlito5::Grammar::block'}->{'capture'};
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                            ref($var) ne 'Perlito5::AST::Var' && return ;
                                            $MATCH->{'_tmp'} = $var;
                                            1
                                        }))
                                    })
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (')' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'sort', 'special_arg' => $MATCH->{'_tmp'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ((do {
                                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::block'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'_tmp'} = $MATCH->{'Perlito5::Grammar::block'}->{'capture'};
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Map::non_core_ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Map::non_core_ident'});
                                            $MATCH->{'_tmp'} = $name;
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 1 : 0
                                        }) && (do {
                                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar::Sigil::term_sigil'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }) && (do {
                                            $MATCH->{'str'} = $str;
                                            my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil::term_sigil'})->[1];
                                            ref($var) ne 'Perlito5::AST::Var' && return ;
                                            $MATCH->{'_tmp'} = $var;
                                            1
                                        }))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'_tmp'} = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'infix:<cmp>', 'arguments' => [Perlito5::AST::Var::->new('name' => 'a', 'namespace' => $Perlito5::PKG, 'sigil' => '$'), Perlito5::AST::Var::->new('name' => 'b', 'namespace' => $Perlito5::PKG, 'sigil' => '$')])]);
                                            1
                                        })
                                    })
                                }) && (do {
                                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'sort', 'special_arg' => $MATCH->{'_tmp'}, 'arguments' => Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression::list_parse'}->{'capture'}), 'namespace' => '')];
                                    1
                                }))
                            })
                        })));
                        $tmp ? $MATCH : 0
                    }
                    Perlito5::Grammar::Precedence::add_term('map' => \&term_map_or_grep);
                    Perlito5::Grammar::Precedence::add_term('grep' => \&term_map_or_grep);
                    Perlito5::Grammar::Precedence::add_term('sort' => \&term_sort);
                    1
                }
            }
            undef();
            {
                {
                    package main;
                    package Perlito5::Grammar::Number;
                    use strict;
                    undef();
                    sub Perlito5::Grammar::Number::term_digit {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $m2 = Perlito5::Grammar::Number::val_octal($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::val_octal'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_octal'})];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Number::val_vstring($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::val_vstring'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_vstring'})];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Number::val_num($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::val_num'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_num'})];
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Number::val_int'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    $MATCH->{'str'} = $str;
                                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_int'})];
                                    1
                                }))
                            })
                        }));
                        $tmp ? $MATCH : 0
                    }
                    Perlito5::Grammar::Precedence::add_term($_ => \&term_digit)
                        for '.', 0 .. 9;
                    sub Perlito5::Grammar::Number::digit {
                        substr($_[0], $_[1], 1) =~ m!\d! ? {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1} : 0
                    }
                    sub Perlito5::Grammar::Number::exponent {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('e' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('E' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            })
                        }) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ('+' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                1
                            })
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            my $count = 0;
                            while ((do {
                                my $pos1 = $MATCH->{'to'};
                                (do {
                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    (do {
                                        my $m2 = digit($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })
                                })
                            }) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'};
                                $count = $count + 1
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            $count > 0
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::val_num {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                    my $m2 = digit($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (do {
                                                my $m2 = digit($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && (do {
                                    my $m = $MATCH;
                                    if (!(do {
                                        my $m2 = exponent($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })) {
                                        $MATCH = $m
                                    }
                                    1
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $m2 = digit($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (do {
                                                my $m2 = digit($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'}
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    1
                                }) && (do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        (do {
                                            my $m2 = exponent($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        (('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                                            my $res = ('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}));
                                            $MATCH = $tmp;
                                            $res ? 0 : 1
                                        }) && (do {
                                            my $last_match_null = 0;
                                            my $m = $MATCH;
                                            my $to = $MATCH->{'to'};
                                            while ((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (do {
                                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                                }) || (do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (do {
                                                        my $m2 = digit($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })
                                                })
                                            }) && ($last_match_null < 2)) {
                                                if ($to == $MATCH->{'to'}) {
                                                    $last_match_null = $last_match_null + 1
                                                }
                                                else {
                                                    $last_match_null = 0
                                                }
                                                $m = $MATCH;
                                                $to = $MATCH->{'to'}
                                            }
                                            $MATCH = $m;
                                            $MATCH->{'to'} = $to;
                                            1
                                        }) && (do {
                                            my $m = $MATCH;
                                            if (!(do {
                                                my $m2 = exponent($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })) {
                                                $MATCH = $m
                                            }
                                            1
                                        }))
                                    })
                                }))
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $s = Perlito5::Match::flat($MATCH);
                            $s =~ s!_!!g;
                            $MATCH->{'capture'} = Perlito5::AST::Num::->new('num' => $s);
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::digits {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            my $count = 0;
                            while ((do {
                                my $m2 = digit($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'};
                                $count = $count + 1
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            $count > 0
                        }));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::digits_underscore {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = digit($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while ((do {
                                my $pos1 = $MATCH->{'to'};
                                (do {
                                    ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    (do {
                                        my $m2 = digit($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    })
                                })
                            }) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::val_octal {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((0 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $pos1 = $MATCH->{'to'};
                            (do {
                                ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('x' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('X' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((do {
                                        my $m2 = Perlito5::Grammar::word($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (do {
                                        ('b' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    }) || (do {
                                        $MATCH->{'to'} = $pos1;
                                        ('B' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                    })
                                }) && (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (0 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (1 eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                }))
                            }) || (do {
                                $MATCH->{'to'} = $pos1;
                                (do {
                                    my $last_match_null = 0;
                                    my $m = $MATCH;
                                    my $to = $MATCH->{'to'};
                                    my $count = 0;
                                    while ((do {
                                        my $pos1 = $MATCH->{'to'};
                                        (do {
                                            ('_' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                                        }) || (do {
                                            $MATCH->{'to'} = $pos1;
                                            (do {
                                                my $m2 = digit($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })
                                        })
                                    }) && ($last_match_null < 2)) {
                                        if ($to == $MATCH->{'to'}) {
                                            $last_match_null = $last_match_null + 1
                                        }
                                        else {
                                            $last_match_null = 0
                                        }
                                        $m = $MATCH;
                                        $to = $MATCH->{'to'};
                                        $count = $count + 1
                                    }
                                    $MATCH = $m;
                                    $MATCH->{'to'} = $to;
                                    $count > 0
                                })
                            })
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => oct(lc(Perlito5::Match::flat($MATCH))));
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::val_int {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = digits_underscore($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $s = Perlito5::Match::flat($MATCH);
                            $s =~ s!_!!g;
                            $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => $s);
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::val_vstring {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = (((do {
                            my $m2 = val_int($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'val_int'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            my $count = 0;
                            while ((('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                my $m2 = digits_underscore($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    if (exists($MATCH->{'digits_underscore'})) {
                                        push(@{$MATCH->{'digits_underscore'}}, $m2)
                                    }
                                    else {
                                        $MATCH->{'digits_underscore'} = [$m2]
                                    }
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'};
                                $count = $count + 1
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            $count > 0
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my @parts = map {
                                Perlito5::Match::flat($_)
                            } @{$MATCH->{'digits_underscore'}};
                            @parts < 2 && return ;
                            $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {
                                chr($_)
                            } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    sub Perlito5::Grammar::Number::val_version {
                        my $str = $_[0];
                        my $pos = $_[1];
                        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                        my $tmp = ((('v' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                            my $m2 = val_int($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'val_int'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while ((('.' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                                my $m2 = digits_underscore($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    if (exists($MATCH->{'digits_underscore'})) {
                                        push(@{$MATCH->{'digits_underscore'}}, $m2)
                                    }
                                    else {
                                        $MATCH->{'digits_underscore'} = [$m2]
                                    }
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my @parts = map {
                                Perlito5::Match::flat($_)
                            } @{$MATCH->{'digits_underscore'}};
                            $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {
                                chr($_)
                            } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
                            1
                        })));
                        $tmp ? $MATCH : 0
                    }
                    1
                }
            }
            sub Perlito5::Grammar::word {
                substr($_[0], $_[1], 1) =~ m!\w! ? {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1} : 0
            }
            sub Perlito5::Grammar::ident {
                (substr($_[0], $_[1], 1) !~ m!\w! || substr($_[0], $_[1], 1) =~ m!\d!) && return ;
                my $m = {'str' => $_[0], 'from' => $_[1], 'to' => $_[1] + 1};
                $m->{'to'}++
                    while substr($_[0], $m->{'to'}, 1) =~ m!\w!;
                $m
            }
            sub Perlito5::Grammar::caret_char {
                my $c = substr($_[0], $_[1], 1);
                my $pos = $_[1];
                if ($c eq '^') {
                    $pos++;
                    $c = substr($_[0], $pos, 1);
                    ($c lt 'A' || $c gt 'Z') && return 0;
                    $c = chr(ord($c) - ord('A') + 1)
                }
                elsif (Perlito5::Grammar::Space::ws($_[0], $pos)) {
                    return 0
                }
                ($c lt chr(1) || $c gt chr(26)) && return 0;
                return {'str' => $_[0], 'from' => $_[1], 'to' => $pos + 1, 'capture' => $c}
            }
            sub Perlito5::Grammar::full_ident {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    while ((('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                        my $m2 = ident($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    })) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {
                            $last_match_null = $last_match_null + 1
                        }
                        else {
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::namespace_before_ident {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = ('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    while ((('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                        my $m2 = ident($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                        $MATCH = $tmp;
                        $res ? 1 : 0
                    })) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {
                            $last_match_null = $last_match_null + 1
                        }
                        else {
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::optional_namespace_before_ident {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m2 = namespace_before_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'namespace_before_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while (('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {
                                    $last_match_null = $last_match_null + 1
                                }
                                else {
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'namespace_before_ident'});
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                            my $m2 = optional_namespace_before_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'optional_namespace_before_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'});
                            $MATCH->{'capture'} = 'main';
                            $name ne '' && ($MATCH->{'capture'} .= '::' . $name);
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (1 && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = '';
                            1
                        }))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::exp_stmts2 {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = exp_stmts($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'exp_stmts'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'exp_stmts'});
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::exp {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::exp2 {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::opt_type {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ((do {
                            my $m = $MATCH;
                            if (!('::' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))) {
                                $MATCH = $m
                            }
                            1
                        }) && (do {
                            my $m2 = full_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'full_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'full_ident'});
                            1
                        }))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (1 && (do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = '';
                            1
                        }))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::var_sigil {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('$' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ('%' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ('@' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ('&' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ('*' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::var_name {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        (do {
                            my $m2 = full_ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'full_ident'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Number::digits'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })
                    })
                }));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::var_ident {
                my $str = $_[0];
                my $pos = $_[1];
                my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
                my $tmp = (((do {
                    my $m2 = var_sigil($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'var_sigil'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = optional_namespace_before_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'optional_namespace_before_ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m2 = var_name($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'var_name'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = Perlito5::AST::Var::->new('sigil' => Perlito5::Match::flat($MATCH->{'var_sigil'}), 'namespace' => Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'}), 'name' => Perlito5::Match::flat($MATCH->{'var_name'}));
                    1
                })));
                $tmp ? $MATCH : 0
            }
            sub Perlito5::Grammar::block {
                Perlito5::Grammar::Block::block(@_)
            }
            sub Perlito5::Grammar::block2 {
                Perlito5::Grammar::Block::block(@_)
            }
            sub Perlito5::Grammar::opt_continue_block {
                Perlito5::Grammar::Block::opt_continue_block(@_)
            }
            my @PKG;
            sub Perlito5::Grammar::exp_stmts {
                my $str = $_[0];
                my $pos = $_[1];
                push(@PKG, $Perlito5::PKG_NAME);
                my $has_semicolon;
                my @stmts;
                my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                $pos = $m->{'to'};
                while ($m) {
                    if (substr($str, $pos, 1) eq ';') {
                        $has_semicolon = 1;
                        $m = Perlito5::Grammar::Space::opt_ws($str, $pos + 1);
                        $pos = $m->{'to'}
                    }
                    else {
                        $m = Perlito5::Grammar::Statement::statement_parse($str, $pos);
                        if ($m) {
                            push(@stmts, $m->{'capture'});
                            $pos = $m->{'to'};
                            if (substr($str, $pos, 1) eq ';') {
                                $has_semicolon = 1;
                                $pos = $pos + 1
                            }
                            $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                            $pos = $m->{'to'}
                        }
                    }
                }
                $Perlito5::PKG_NAME = pop(@PKG);
                $Perlito5::BLOCK_HAS_SEMICOLON ||= $has_semicolon;
                return {'str' => $str, 'to' => $pos, 'capture' => \@stmts}
            }
        }
    }
    use strict;
    my %Perlito_internal_module = ('strict' => 'Perlito5X::strict', 'warnings' => 'Perlito5X::warnings', 'feature' => 'Perlito5X::feature', 'utf8' => 'Perlito5X::utf8', 'bytes' => 'Perlito5X::bytes', 'encoding' => 'Perlito5X::encoding', 'Carp' => 'Perlito5X::Carp', 'Exporter' => 'Perlito5X::Exporter', 'Data::Dumper' => 'Perlito5X::Dumper');
    sub Perlito5::Grammar::Use::use_decl {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('use' eq substr($str, $MATCH->{'to'}, 3) && ($MATCH->{'to'} = 3 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('no' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Use::version_string {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::val_version'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    $MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar::Number::val_version'}->{'capture'};
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::term_digit'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    my $version = $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'buf'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'int'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'num'};
                    $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => $version);
                    1
                }))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Use::term_require {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('require' eq substr($str, $MATCH->{'to'}, 7) && ($MATCH->{'to'} = 7 + $MATCH->{'to'})) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = version_string($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'version_string'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    my $version = $MATCH->{'version_string'}->{'capture'};
                    $version->{'is_version_string'} = 1;
                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [$version])];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    my $module_name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                    my $filename = modulename_to_filename($module_name);
                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => $filename)])];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Use::stmt_use {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = use_decl($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'use_decl'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((do {
                    my $m2 = version_string($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'version_string'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    my $version = $MATCH->{'version_string'}->{'capture'}->{'buf'};
                    Perlito5::test_perl_version($version);
                    $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => []);
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $m = $MATCH;
                    if (!(('-' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                        my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            if (exists($MATCH->{'Perlito5::Grammar::ident'})) {
                                push(@{$MATCH->{'Perlito5::Grammar::ident'}}, $m2)
                            }
                            else {
                                $MATCH->{'Perlito5::Grammar::ident'} = [$m2]
                            }
                            1
                        }
                        else {
                            0
                        }
                    }))) {
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!((do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $m2 = version_string($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            if (exists($MATCH->{'version_string'})) {
                                push(@{$MATCH->{'version_string'}}, $m2)
                            }
                            else {
                                $MATCH->{'version_string'} = [$m2]
                            }
                            1
                        }
                        else {
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {
                            0
                        }
                    }))) {
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Expression::list_parse'} = $m2;
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    $MATCH->{'str'} = $str;
                    my $version = $MATCH->{'version_string'}->[0]->{'capture'}->{'buf'};
                    my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::list_parse'});
                    if ($list eq '*undef*') {
                        $list = undef
                    }
                    else {
                        my $m = $MATCH->{'Perlito5::Grammar::Expression::list_parse'};
                        my $list_code = substr($str, $m->{'from'}, $m->{'to'} - $m->{'from'});
                        my @list = eval($list_code);
                        $list = \@list
                    }
                    my $full_ident = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                    $Perlito5::PACKAGES->{$full_ident} = 1;
                    my $use_decl = Perlito5::Match::flat($MATCH->{'use_decl'});
                    if ($use_decl eq 'use' && $full_ident eq 'vars' && $list) {
                        my $code = 'our (' . join(', ', @{$list}) . ')';
                        my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                        !$m && die('not a valid variable name: ' . join(${'"'}, @{$list}));
                        $MATCH->{'capture'} = $m->{'capture'}
                    }
                    elsif ($full_ident eq 'strict') {
                        $Perlito5::STRICT = ($use_decl eq 'no' ? 0 : 1);
                        my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                        $MATCH->{'capture'} = $ast
                    }
                    elsif ($use_decl eq 'use' && $full_ident eq 'constant' && $list) {
                        my @ast;
                        my $name = shift(@{$list});
                        if (ref($name) eq 'HASH') {
                            for my $key (sort {
                                $a cmp $b
                            } keys(%{$name})) {
                                my $code = 'sub ' . $key . ' () { ' . Perlito5::Dumper::_dumper($name->{$key}) . ' }';
                                my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                                !$m && die('not a valid constant: ' . join(${'"'}, @{$list}));
                                push(@ast, $m->{'capture'})
                            }
                        }
                        else {
                            my $code = 'sub ' . $name . ' () { (' . join(', ', map {
                                Perlito5::Dumper::_dumper($_)
                            } @{$list}) . ') }';
                            my $m = Perlito5::Grammar::Statement::statement_parse($code, 0);
                            !$m && die('not a valid constant: ' . join(${'"'}, @{$list}));
                            push(@ast, $m->{'capture'})
                        }
                        $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => \@ast)
                    }
                    else {
                        my $ast = Perlito5::AST::Use::->new('code' => $use_decl, 'mod' => $full_ident, 'arguments' => $list);
                        $MATCH->{'capture'} = parse_time_eval($ast)
                    }
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    $MATCH->{'str'} = $str;
                    die('Syntax error');
                    1
                })
            })
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::Use::parse_time_eval {
        my $ast = shift;
        my $module_name = $ast->mod();
        my $use_or_not = $ast->code();
        my $arguments = $ast->{'arguments'};
        my $skip_import = defined($arguments) && @{$arguments} == 0;
        defined($arguments) || ($arguments = []);
        my $comp_units = [];
        expand_use($comp_units, $ast);
        if ($Perlito5::EXPAND_USE) {
            my $current_module_name = $Perlito5::PKG_NAME;
            my $filename = modulename_to_filename($module_name);
            require($filename);
            if (!$skip_import) {
                if ($use_or_not eq 'use') {
                    if (defined(&{$module_name . '::import'})) {
                        unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                        eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->import(@$arguments); 1') or die(${'@'});
                        shift(@{$Perlito5::CALLER})
                    }
                }
                elsif ($use_or_not eq 'no') {
                    if (defined(&{$module_name . '::unimport'})) {
                        unshift(@{$Perlito5::CALLER}, [$current_module_name]);
                        eval('package ' . $current_module_name . ';' . chr(10) . '$module_name->unimport(@$arguments); 1') or die(${'@'});
                        shift(@{$Perlito5::CALLER})
                    }
                }
            }
        }
        if (@{$comp_units}) {
            return Perlito5::AST::Block::->new('stmts' => $comp_units)
        }
        else {
            return Perlito5::AST::Apply::->new('code' => 'undef', 'namespace' => '', 'arguments' => [])
        }
    }
    sub Perlito5::Grammar::Use::emit_time_eval {
        my $ast = shift;
        if ($ast->mod() eq 'strict') {
            if ($ast->code() eq 'use') {
                strict::->import()
            }
            elsif ($ast->code() eq 'no') {
                strict::->unimport()
            }
        }
    }
    sub Perlito5::Grammar::Use::modulename_to_filename {
        my $s = shift;
        exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
        $s =~ s!::!/!g;
        return $s . '.pm'
    }
    sub Perlito5::Grammar::Use::filename_lookup {
        my $filename = shift;
        if (exists($INC{$filename})) {
            $INC{$filename} && return 'done';
            die('Compilation failed in require')
        }
        for my $prefix (@INC, '.') {
            my $realfilename = $prefix . '/' . $filename;
            if (-f $realfilename) {
                $INC{$filename} = $realfilename;
                return 'todo'
            }
        }
        die('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').')
    }
    sub Perlito5::Grammar::Use::expand_use {
        my $comp_units = shift;
        my $stmt = shift;
        my $module_name = $stmt->mod();
        my $filename = modulename_to_filename($module_name);
        filename_lookup($filename) eq 'done' && return ;
        local $Perlito5::FILE_NAME = $filename;
        local $Perlito5::LINE_NUMBER = 1;
        my $realfilename = $INC{$filename};
        open(FILE, '<', $realfilename) or die('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        $m->{'to'} != length($source) && die('Syntax Error near ', $m->{'to'});
        if ($m->{'to'} != length($source)) {
            my $pos = $m->{'to'} - 10;
            $pos < 0 && ($pos = 0);
            print('* near: ', substr($source, $pos, 20), chr(10));
            print('* filename: ' . $realfilename . chr(10));
            die('Syntax Error near ', $m->{'to'})
        }
        if ($ENV{'PERLITO5DEV'}) {
            push(@{$comp_units}, Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m)));
            return 
        }
        push(@{$comp_units}, @{add_comp_unit([Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m))])});
        return 
    }
    sub Perlito5::Grammar::Use::add_comp_unit {
        my $parse = shift;
        my $comp_units = [];
        for my $comp_unit (@{$parse}) {
            if (defined($comp_unit)) {
                if ($comp_unit->isa('Perlito5::AST::Use')) {
                    expand_use($comp_units, $comp_unit)
                }
                elsif ($comp_unit->isa('Perlito5::AST::CompUnit')) {
                    for my $stmt (@{$comp_unit->body()}) {
                        if ($stmt->isa('Perlito5::AST::Use')) {
                            expand_use($comp_units, $stmt)
                        }
                    }
                }
                push(@{$comp_units}, $comp_unit)
            }
        }
        return $comp_units
    }
    sub Perlito5::Grammar::Use::require {
        my $filename = shift;
        filename_lookup($filename) eq 'done' && return ;
        my $result = do($filename);
        if (${'@'}) {
            $INC{$filename} = undef;
            die(${'@'})
        }
        elsif (!$result) {
            delete($INC{$filename});
            ${'@'} && warn(${'@'});
            die($filename . ' did not return true value')
        }
        else {
            return $result
        }
    }
    sub Perlito5::Grammar::Use::do_file {
        my $filename = shift;
        eval {
            filename_lookup($filename);
            1
        } or do {
            $INC{$filename} = undef;
            ${'@'} = '';
            ${'!'} = 'No such file or directory';
            return 'undef'
        };
        my $realfilename = $INC{$filename};
        open(FILE, '<', $realfilename) or die('Cannot read ' . $realfilename . ': ' . ${'!'} . chr(10));
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        return $source
    }
    Perlito5::Grammar::Statement::add_statement('no' => \&stmt_use);
    Perlito5::Grammar::Statement::add_statement('use' => \&stmt_use);
    Perlito5::Grammar::Precedence::add_term('require' => \&term_require);
    1
}
;1
