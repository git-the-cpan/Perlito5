# Do not edit this file - Generated by Perlito5 9.009
{
    package main;
    undef();
    package Perlito5::Grammar::String;
    {
        {
            package main;
            package Perlito5::Grammar::Precedence;
            {
                {
                    package main;
                    package feature;
                    sub feature::import {}
                    sub feature::unimport {}
                    1
                }
            }
            sub Perlito5::Grammar::Precedence::new {
                my $class = shift;
                bless({@_}, $class)
            }
            my $Operator = {};
            my $Precedence = {};
            my $PrefixPrecedence = {};
            my $Assoc = {};
            sub Perlito5::Grammar::Precedence::is_assoc_type {
                my $assoc_type = shift;
                my $op_name = shift;
                return $Assoc->{$assoc_type}->{$op_name}
            }
            sub Perlito5::Grammar::Precedence::is_fixity_type {
                my $fixity_type = shift;
                my $op_name = shift;
                return $Operator->{$fixity_type}->{$op_name}
            }
            sub Perlito5::Grammar::Precedence::is_term {
                my $token = shift;
                ($token->[0] eq 'term') || ($token->[0] eq 'postfix_or_term') || ($token->[0] eq 'postfix')
            }
            sub Perlito5::Grammar::Precedence::is_num {
                $_[0] ge 0 && $_[0] le 9
            }
            sub Perlito5::Grammar::Precedence::is_ident_middle {
                my $c = shift;
                ($c ge 'a' && $c le 'z') || ($c ge 0 && $c le 9) || ($c eq '_')
            }
            my @Parsed_op_chars = (2, 1);
            my %Parsed_op = ('?' => sub {
                Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
            }, '(' => sub {
                Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
            }, '[' => sub {
                Perlito5::Grammar::Expression::term_square($_[0], $_[1])
            }, '{' => sub {
                Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
            }, '->' => sub {
                Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
            });
            my @Term_chars;
            my %Term;
            sub Perlito5::Grammar::Precedence::add_term {
                my $name = shift;
                my $param = shift;
                $Term{$name} = $param;
                unshift(@Term_chars, scalar(@Term_chars) + 1)
                    while @Term_chars < length($name)
            }
            my $End_token;
            my $End_token_chars;
            my %Op;
            my @Op_chars = (3, 2, 1);
            sub Perlito5::Grammar::Precedence::op_parse {
                my $str = shift;
                my $pos = shift;
                my $last_is_term = shift;
                for my $len (@{$End_token_chars}) {
                    my $term = substr($str, $pos, $len);
                    if (exists($End_token->{$term})) {
                        my $c1 = substr($str, $pos + $len - 1, 1);
                        my $c2 = substr($str, $pos + $len, 1);
                        if (!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '<' && $c2 eq '<')) {
                            return {'str' => $str, 'from' => $pos, 'to' => $pos, 'capture' => ['end', $term]}
                        }
                    }
                }
                if (!$last_is_term) {
                    for my $len (@Term_chars) {
                        my $term = substr($str, $pos, $len);
                        if (exists($Term{$term})) {
                            my $c1 = substr($str, $pos + $len - 1, 1);
                            my $c2 = substr($str, $pos + $len, 1);
                            if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                                my $m = $Term{$term}->($str, $pos);
                                $m && return $m
                            }
                        }
                    }
                }
                for my $len (@Parsed_op_chars) {
                    my $op = substr($str, $pos, $len);
                    if (exists($Parsed_op{$op})) {
                        my $m = $Parsed_op{$op}->($str, $pos);
                        $m && return $m
                    }
                }
                for my $len (@Op_chars) {
                    my $op = substr($str, $pos, $len);
                    if (exists($Op{$op})) {
                        my $c1 = substr($str, $pos + $len - 1, 1);
                        my $c2 = substr($str, $pos + $len, 1);
                        if ((!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq '&' && $c2 eq '&')) || ($c1 eq 'x' && $c2 ge 0 && $c2 le 9)) {
                            if (exists($Operator->{'infix'}->{$op}) && !exists($Operator->{'prefix'}->{$op}) && !$last_is_term) {}
                            else {
                                return {'str' => $str, 'from' => $pos, 'to' => $pos + $len, 'capture' => ['op', $op]}
                            }
                        }
                    }
                }
                return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
            }
            sub Perlito5::Grammar::Precedence::add_op {
                my($fixity, $names, $precedence, $param) = @_;
                $param //= {};
                my $assoc = $param->{'assoc'} || 'left';
                for my $name (@{$names}) {
                    $Operator->{$fixity}->{$name} = 1;
                    $Precedence->{$name} = $precedence;
                    $fixity eq 'prefix' && ($PrefixPrecedence->{$name} = $precedence);
                    $Assoc->{$assoc}->{$name} = 1;
                    $Op{$name} = 1
                }
            }
            my $prec = 100;
            add_op('postfix', ['.( )', '.[ ]', '.{ }', '( )', '[ ]', 'funcall', 'funcall_no_params', 'methcall', 'methcall_no_params', 'block', 'hash'], $prec);
            $prec = $prec - 1;
            add_op('prefix', ['++', '--'], $prec);
            add_op('postfix', ['++', '--'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['**'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('prefix', [chr(92), '+', '-', '~', '!'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['=~', '!~'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['*', '/', '%', 'x'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['+', '-'], $prec);
            add_op('infix', ['.'], $prec, {'assoc' => 'list'});
            $prec = $prec - 1;
            add_op('infix', ['<<', '>>'], $prec);
            $prec = $prec - 1;
            add_op('prefix', ['-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['lt', 'le', 'gt', 'ge', '<=', '>=', '<', '>'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['<=>', 'cmp', '==', '!=', 'ne', 'eq'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['&'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['|', '^'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['..', '...'], $prec);
            add_op('infix', ['~~'], $prec, {'assoc' => 'chain'});
            $prec = $prec - 1;
            add_op('infix', ['&&'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['||'], $prec, {'assoc' => 'right'});
            add_op('infix', ['//'], $prec);
            $prec = $prec - 1;
            add_op('ternary', ['? :'], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['=', '**=', '+=', '-=', '*=', '/=', 'x=', '|=', '&=', '.=', '<<=', '>>=', '%=', '||=', '&&=', '^=', '//='], $prec, {'assoc' => 'right'});
            $prec = $prec - 1;
            add_op('infix', ['=>'], $prec);
            $prec = $prec - 1;
            add_op('list', [','], $prec, {'assoc' => 'list'});
            $prec = $prec - 1;
            add_op('prefix', ['not'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['and'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['or', 'xor'], $prec);
            $prec = $prec - 1;
            add_op('infix', ['*start*'], $prec);
            sub Perlito5::Grammar::Precedence::get_token_precedence {
                my $token = $_[0];
                if ($token->[0] eq 'prefix') {
                    return $PrefixPrecedence->{$token->[1]}
                }
                return $Precedence->{$token->[1]}
            }
            sub Perlito5::Grammar::Precedence::precedence_parse {
                my $self = shift;
                my $get_token = $self->{'get_token'};
                my $reduce = $self->{'reduce'};
                my $last_end_token = $End_token;
                my $last_end_token_chars = $End_token_chars;
                $End_token = $self->{'end_token'};
                $End_token_chars = $self->{'end_token_chars'};
                my $op_stack = [];
                my $num_stack = [];
                my $last = ['op', '*start*'];
                my $last_is_term = 0;
                my $token = $get_token->($last_is_term);
                if ($token->[0] eq 'space') {
                    $token = $get_token->($last_is_term)
                }
                while ((defined($token)) && ($token->[0] ne 'end')) {
                    my $token_is_term = is_term($token);
                    if (($token->[1] eq ',') && (($last->[1] eq '*start*') || ($last->[1] eq ','))) {
                        push(@{$num_stack}, ['term', undef])
                    }
                    if ($Operator->{'prefix'}->{$token->[1]} && (($last->[1] eq '*start*') || !$last_is_term)) {
                        $token->[0] = 'prefix';
                        unshift(@{$op_stack}, $token)
                    }
                    elsif ($Operator->{'postfix'}->{$token->[1]} && $last_is_term) {
                        my $pr = $Precedence->{$token->[1]};
                        while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                            $reduce->($op_stack, $num_stack)
                        }
                        if ($token->[0] ne 'postfix_or_term') {
                            $token->[0] = 'postfix'
                        }
                        unshift(@{$op_stack}, $token);
                        $token_is_term = 1
                    }
                    elsif ($token_is_term) {
                        if ($last_is_term) {
                            print('#      last:  ', Data::Dumper::Dumper($last));
                            print('#      token: ', Data::Dumper::Dumper($token));
                            die('Value tokens must be separated by an operator')
                        }
                        $token->[0] = 'term';
                        push(@{$num_stack}, $token)
                    }
                    elsif ($Precedence->{$token->[1]}) {
                        my $pr = $Precedence->{$token->[1]};
                        if ($Assoc->{'right'}->{$token->[1]}) {
                            while (scalar(@{$op_stack}) && ($pr < get_token_precedence($op_stack->[0]))) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        else {
                            while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        if ($Operator->{'ternary'}->{$token->[1]}) {
                            $token->[0] = 'ternary'
                        }
                        else {
                            $token->[0] = 'infix'
                        }
                        unshift(@{$op_stack}, $token)
                    }
                    else {
                        die('Unknown token: ' . chr(39), $token->[1], chr(39))
                    }
                    $last = $token;
                    $last_is_term = $token_is_term;
                    $token = $get_token->($last_is_term);
                    if ($token->[0] eq 'space') {
                        $token = $get_token->($last_is_term)
                    }
                }
                if (defined($token) && ($token->[0] ne 'end')) {
                    die('Unexpected end token: ', $token)
                }
                while (scalar(@{$op_stack})) {
                    $reduce->($op_stack, $num_stack)
                }
                $End_token = $last_end_token;
                $End_token_chars = $last_end_token_chars;
                return $num_stack
            }
            1
        }
    }
    sub Perlito5::Grammar::String::term_q_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('q' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (chr(39) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            })
        }) && (do {
            my $m2 = q_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'q_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'q_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_qq_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('qq' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('"' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            })
        }) && (do {
            my $m2 = qq_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'qq_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qq_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_qw_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('qw' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            })
        }) && (do {
            my $m2 = qw_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'qw_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qw_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_m_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('m' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('/' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            })
        }) && (do {
            my $m2 = m_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'m_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'m_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_s_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('s' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            })
        }) && (do {
            my $m2 = s_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'s_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'s_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_qx {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                (('qx' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {
                        ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
                    })
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('`' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            })
        }) && (do {
            my $m2 = qx_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'qx_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qx_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_glob {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('<' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
            my $m2 = glob_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'glob_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'glob_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_tr_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('tr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ('y' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            })
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            })
        }) && (do {
            my $m2 = tr_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'tr_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'tr_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::term_qr_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((('qr' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'})) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ('#' eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {'str' => $str, 'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                    my $res = ('=>' eq substr($str, $MATCH->{'to'}, 2) && ($MATCH->{'to'} = 2 + $MATCH->{'to'}));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})))
            })
        }) && (do {
            my $m2 = qr_quote_parse($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'qr_quote_parse'} = $m2;
                1
            }
            else {
                0
            }
        }) && (do {
            $MATCH->{'str'} = $str;
            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qr_quote_parse'})];
            1
        })));
        $tmp ? $MATCH : 0
    }
    my %pair = ('{' => '}', '(' => ')', '[' => ']', '<' => '>');
    my %escape_sequence = ('a', 7, 'b', 8, 'e', 27, 'f', 12, 'n', 10, 'r', 13, 't', 9);
    my %hex = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F');
    my %octal = map(+($_ => 1), 0, 1, 2, 3, 4, 5, 6, 7);
    sub Perlito5::Grammar::String::q_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
    }
    sub Perlito5::Grammar::String::qq_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
    }
    sub Perlito5::Grammar::String::qw_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
        if ($m) {
            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'list:<,>', 'arguments' => [map(Perlito5::AST::Buf::->new('buf' => $_), split(' ', Perlito5::Match::flat($m)->{'buf'}))], 'namespace' => '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::m_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq chr(39) && ($interpolate = 3);
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = $part1->{'capture'};
        my $p = $part1->{'to'};
        my $modifiers = '';
        my $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part1->{'to'} = $m->{'to'}
        }
        $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:m', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
        return $part1
    }
    sub Perlito5::Grammar::String::s_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
        $part1 || return $part1;
        my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
        my $part2;
        my $m;
        my $p = $part1->{'to'};
        if (exists($pair{$delimiter})) {
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{'to'};
            $delimiter = substr($str, $p, 1);
            my $open_delimiter = $delimiter;
            $p++;
            $closing_delimiter = $delimiter;
            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
            $part2 || return $part2
        }
        else {
            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
            $part2 || return $part2
        }
        $p = $part2->{'to'};
        my $modifiers = '';
        $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m)
        }
        my $replace;
        if ($modifiers =~ m!e!) {
            delete($part2->{'capture'});
            $replace = Perlito5::Match::flat($part2);
            $replace = substr($replace, 0, -1);
            $replace = '{' . $replace . '}';
            my $m = Perlito5::Grammar::block($replace, 0);
            if (!$m) {
                die('syntax error')
            }
            $replace = Perlito5::Match::flat($m);
            if ($modifiers =~ m!ee!) {
                $replace = Perlito5::AST::Block::->new('sig' => undef, 'stmts' => [Perlito5::AST::Apply::->new('code' => 'eval', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'do', 'arguments' => [$replace])], 'bareword' => '', 'namespace' => '')])
            }
        }
        else {
            $replace = Perlito5::Match::flat($part2)
        }
        if ($m) {
            $part2->{'to'} = $m->{'to'}
        }
        $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:s', 'arguments' => [$str_regex, $replace, Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
        return $part2
    }
    sub Perlito5::Grammar::String::qr_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq chr(39) && ($interpolate = 3);
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = $part1->{'capture'};
        my $p = $part1->{'to'};
        my $modifiers = '';
        my $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part1->{'to'} = $m->{'to'}
        }
        $part1->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:qr', 'arguments' => [$str_regex, Perlito5::AST::Buf::->new('buf' => $modifiers)], 'namespace' => '');
        return $part1
    }
    sub Perlito5::Grammar::String::qx_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
        if ($m) {
            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'qx', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::glob_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        if (substr($str, $pos, 3) eq '<>>') {
            return {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => '<>', 'arguments' => [], 'namespace' => '', 'bareword' => 1)], 'namespace' => '')}
        }
        if (substr($str, $pos, 1) eq '>') {
            return {'str' => $str, 'from' => $pos, 'to' => $pos + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [], 'namespace' => '')}
        }
        my $p = $pos;
        my $sigil = '::';
        if (substr($str, $p, 1) eq '$') {
            $sigil = '$';
            $p++
        }
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{'to'};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if ($m_name && substr($str, $m_name->{'to'}, 1) eq '>') {
            if ($sigil eq '::') {
                return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Apply::->new('code' => Perlito5::Match::flat($m_name), 'arguments' => [], 'namespace' => $namespace, 'bareword' => 1)], 'namespace' => '')}
            }
            return {'str' => $str, 'from' => $pos, 'to' => $m_name->{'to'} + 1, 'capture' => Perlito5::AST::Apply::->new('code' => 'readline', 'arguments' => [Perlito5::AST::Var::->new('sigil' => $sigil, 'name' => Perlito5::Match::flat($m_name), 'namespace' => $namespace)], 'namespace' => '')}
        }
        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1);
        if ($m) {
            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'glob', 'arguments' => [Perlito5::Match::flat($m)], 'namespace' => '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::tr_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = substr($str, $pos - 1, 1);
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
        $part1 || return $part1;
        my $str_regex = Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $part1->{'to'} - $pos - 1));
        my $part2;
        my $m;
        my $p = $part1->{'to'};
        if (exists($pair{$delimiter})) {
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{'to'};
            $delimiter = substr($str, $p, 1);
            my $open_delimiter = $delimiter;
            $p++;
            $closing_delimiter = $delimiter;
            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
            $part2 || return $part2
        }
        else {
            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
            $part2 || return $part2
        }
        $p = $part2->{'to'};
        my $modifiers = '';
        $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part2->{'to'} = $m->{'to'}
        }
        $part2->{'capture'} = Perlito5::AST::Apply::->new('code' => 'p5:tr', 'arguments' => [$str_regex, Perlito5::Match::flat($part2), Perlito5::AST::Buf::->new('buf' => $modifiers), Perlito5::AST::Var::->new('sigil' => '$', 'namespace' => '', 'name' => '_')], 'namespace' => '');
        return $part2
    }
    sub Perlito5::Grammar::String::apply_quote_flags {
        my($c, $quote_flags) = @_;
        length($c) || return $c;
        if ($quote_flags->{'l'}) {
            $c = lcfirst($c);
            delete($quote_flags->{'l'})
        }
        if ($quote_flags->{'u'}) {
            $c = ucfirst($c);
            delete($quote_flags->{'u'})
        }
        $quote_flags->{'L'} && ($c = lc($c));
        $quote_flags->{'U'} && ($c = uc($c));
        $quote_flags->{'Q'} && ($c = quotemeta($c));
        return $c
    }
    sub Perlito5::Grammar::String::string_interpolation_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $open_delimiter = $_[2];
        my $delimiter = $_[3];
        my $interpolate = $_[4];
        my $quote_flags = $_[5] || {};
        my $interpolate_vars = ($interpolate == 1 || $interpolate == 2);
        my $p = $pos;
        my $balanced = $open_delimiter && exists($pair{$open_delimiter});
        my @args;
        my $buf = '';
        while ($p < length($str) && substr($str, $p, length($delimiter)) ne $delimiter) {
            my $c = substr($str, $p, 1);
            my $c2 = substr($str, $p + 1, 1);
            my $m;
            my $more = '';
            if ($balanced && $c eq chr(92) && ($c2 eq $open_delimiter || $c2 eq $delimiter)) {
                $p++;
                $c = $c2
            }
            elsif ($balanced && $c eq $open_delimiter) {
                $buf .= $c;
                $p++;
                $m = string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate, $quote_flags);
                $more = $delimiter
            }
            elsif ($interpolate_vars && ($c eq '$' || $c eq '@')) {
                my $match = Perlito5::Grammar::String::double_quoted_var($str, $p, $delimiter, $interpolate);
                if ($match) {
                    my $ast = $match->{'capture'};
                    if ($quote_flags->{'l'}) {
                        $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lcfirst', 'arguments' => [$ast]);
                        delete($quote_flags->{'l'})
                    }
                    if ($quote_flags->{'u'}) {
                        $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'ucfirst', 'arguments' => [$ast]);
                        delete($quote_flags->{'u'})
                    }
                    $quote_flags->{'L'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'lc', 'arguments' => [$ast]));
                    $quote_flags->{'U'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'uc', 'arguments' => [$ast]));
                    $quote_flags->{'Q'} && ($ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'quotemeta', 'arguments' => [$ast]));
                    $match->{'capture'} = $ast
                }
                $m = $match
            }
            elsif ($c eq chr(92)) {
                if ($interpolate) {
                    if ($c2 eq 'E') {
                        my $flag_to_reset = $quote_flags->{'last_flag'};
                        if ($flag_to_reset) {
                            delete($quote_flags->{$flag_to_reset});
                            delete($quote_flags->{'last_flag'})
                        }
                        else {
                            $quote_flags = {}
                        }
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq 'L') {
                        $quote_flags->{$c2} = 1;
                        delete($quote_flags->{'U'});
                        $quote_flags->{'last_flag'} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq 'U') {
                        $quote_flags->{$c2} = 1;
                        delete($quote_flags->{'L'});
                        $quote_flags->{'last_flag'} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq 'Q') {
                        $quote_flags->{$c2} = 1;
                        $quote_flags->{'last_flag'} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq 'l') {
                        $quote_flags->{'u'} || ($quote_flags->{$c2} = 1);
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq 'u') {
                        $quote_flags->{'l'} || ($quote_flags->{$c2} = 1);
                        $p += 1;
                        $c = ''
                    }
                }
                if ($c) {
                    if ($interpolate == 2) {
                        $m = {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => substr($str, $p, 2))}
                    }
                    elsif ($interpolate == 1) {
                        $m = Perlito5::Grammar::String::double_quoted_unescape($str, $p)
                    }
                    else {
                        $m = $c2 eq chr(92) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(92))} : $c2 eq chr(39) ? {'str' => $str, 'from' => $p, 'to' => $p + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr(39))} : 0
                    }
                }
            }
            if ($m) {
                my $obj = Perlito5::Match::flat($m);
                if (ref($obj) eq 'Perlito5::AST::Buf') {
                    $buf .= apply_quote_flags($obj->{'buf'}, $quote_flags);
                    $obj = undef
                }
                if ($obj) {
                    if (length($buf)) {
                        push(@args, Perlito5::AST::Buf::->new('buf' => $buf));
                        $buf = ''
                    }
                    push(@args, $obj)
                }
                $p = $m->{'to'};
                $buf .= $more
            }
            else {
                $p++;
                if ($c eq chr(10) || $c eq chr(13)) {
                    my $m = here_doc($str, $p);
                    if ($p != $m->{'to'}) {
                        $p = $m->{'to'}
                    }
                    else {
                        $buf .= apply_quote_flags($c, $quote_flags)
                    }
                }
                else {
                    $buf .= apply_quote_flags($c, $quote_flags)
                }
            }
        }
        if (length($buf)) {
            push(@args, Perlito5::AST::Buf::->new('buf' => $buf))
        }
        substr($str, $p, length($delimiter)) ne $delimiter && die('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF');
        $p += length($delimiter);
        my $ast;
        if (!@args) {
            $ast = Perlito5::AST::Buf::->new('buf' => '')
        }
        elsif (@args == 1) {
            $ast = $args[0]
        }
        else {
            $ast = Perlito5::AST::Apply::->new('namespace' => '', 'code' => 'list:<.>', 'arguments' => \@args)
        }
        return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => $ast}
    }
    our @Here_doc;
    sub Perlito5::Grammar::String::here_doc_wanted {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter;
        my $type = 'double_quote';
        my $p = $pos;
        if (substr($str, $p, 2) eq '<<') {
            $p += 2;
            my $quote = substr($str, $p, 1);
            if ($quote eq chr(39) || $quote eq '"') {
                $p += 1;
                my $m = string_interpolation_parse($str, $p, $quote, $quote, 0);
                if ($m) {
                    $p = $m->{'to'};
                    $delimiter = Perlito5::Match::flat($m)->{'buf'};
                    $type = $quote eq chr(39) ? 'single_quote' : 'double_quote'
                }
            }
            else {
                $quote eq chr(92) && ($p += 1);
                my $m = Perlito5::Grammar::ident($str, $p);
                if ($m) {
                    $p = $m->{'to'};
                    $delimiter = Perlito5::Match::flat($m);
                    $type = $quote eq chr(92) ? 'single_quote' : 'double_quote'
                }
                else {
                    $Perlito5::WARNINGS && warn('Use of bare << to mean <<"" is deprecated');
                    $delimiter = '';
                    $type = 'double_quote'
                }
            }
        }
        if (!defined($delimiter)) {
            return 0
        }
        my $placeholder = Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [Perlito5::AST::Apply::->new('code' => 'list:<.>', 'namespace' => '', 'arguments' => [])]);
        push(@Here_doc, [$type, $placeholder->{'arguments'}->[0]->{'arguments'}, $delimiter]);
        return {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => ['term', $placeholder]}
    }
    sub Perlito5::Grammar::String::newline {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {
                ((chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m = $MATCH;
                    if (!(chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                        $MATCH = $m
                    }
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((chr(13) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'})) && (do {
                    my $m = $MATCH;
                    if (!(chr(10) eq substr($str, $MATCH->{'to'}, 1) && ($MATCH->{'to'} = 1 + $MATCH->{'to'}))) {
                        $MATCH = $m
                    }
                    1
                }))
            })
        }));
        $tmp ? $MATCH : 0
    }
    sub Perlito5::Grammar::String::here_doc {
        my $str = $_[0];
        my $pos = $_[1];
        if (!@Here_doc) {
            return {'str' => $str, 'from' => $pos, 'to' => $pos}
        }
        my $p = $pos;
        my $here = shift(@Here_doc);
        my $type = $here->[0];
        my $result = $here->[1];
        my $delimiter = $here->[2];
        if ($type eq 'single_quote') {
            while ($p < length($str)) {
                if (substr($str, $p, length($delimiter)) eq $delimiter) {
                    push(@{$result}, Perlito5::AST::Buf::->new('buf' => substr($str, $pos, $p - $pos)));
                    $p += length($delimiter);
                    my $m = newline($str, $p);
                    if ($p >= length($str) || $m) {
                        $m && ($p = $m->{'to'});
                        return {'str' => $str, 'from' => $pos, 'to' => $p - 1}
                    }
                }
                while ($p < length($str) && (substr($str, $p, 1) ne chr(10) && substr($str, $p, 1) ne chr(13))) {
                    $p++
                }
                while ($p < length($str) && (substr($str, $p, 1) eq chr(10) || substr($str, $p, 1) eq chr(13))) {
                    $p++
                }
            }
        }
        else {
            my $m;
            if (substr($str, $p, length($delimiter)) eq $delimiter) {
                $p += length($delimiter);
                $m = newline($str, $p);
                if ($p >= length($str) || $m) {
                    push(@{$result}, Perlito5::AST::Buf::->new('buf' => ''));
                    $m && ($p = $m->{'to'});
                    return {'str' => $str, 'from' => $pos, 'to' => $p}
                }
            }
            $m = string_interpolation_parse($str, $pos, '', chr(10) . $delimiter . chr(10), 1);
            if ($m) {
                push(@{$result}, Perlito5::Match::flat($m));
                push(@{$result}, Perlito5::AST::Buf::->new('buf' => chr(10)));
                $m->{'to'} = $m->{'to'} - 1;
                return $m
            }
        }
        die('Can' . chr(39) . 't find string terminator "' . $delimiter . '" anywhere before EOF')
    }
    sub Perlito5::Grammar::String::double_quoted_unescape {
        my $str = $_[0];
        my $pos = $_[1];
        my $c2 = substr($str, $pos + 1, 1);
        my $m;
        if (exists($escape_sequence{$c2})) {
            $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($escape_sequence{$c2}))}
        }
        elsif ($c2 eq 'c') {
            my $c3 = ord(uc(substr($str, $pos + 2, 1))) - ord('A') + 1;
            $c3 < 0 && ($c3 = 128 + $c3);
            $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 3, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($c3))}
        }
        elsif ($c2 eq 'x') {
            if (substr($str, $pos + 2, 1) eq '{') {
                my $p = $pos + 3;
                $p++
                    while $p < length($str) && substr($str, $p, 1) ne '}';
                my $hex_code = substr($str, $pos + 3, $p - $pos - 3);
                $hex_code || ($hex_code = 0);
                my $tmp = oct('0x' . $hex_code);
                $m = {'str' => $str, 'from' => $pos, 'to' => $p + 1, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
            }
            else {
                my $p = $pos + 2;
                $hex{uc(substr($str, $p, 1))} && $p++;
                $hex{uc(substr($str, $p, 1))} && $p++;
                my $hex_code = substr($str, $pos + 2, $p - $pos - 2);
                $hex_code || ($hex_code = 0);
                my $tmp = oct('0x' . $hex_code);
                $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
            }
        }
        elsif (exists($octal{$c2})) {
            my $p = $pos + 1;
            $octal{substr($str, $p, 1)} && $p++;
            $octal{substr($str, $p, 1)} && $p++;
            $octal{substr($str, $p, 1)} && $p++;
            my $oct_code = substr($str, $pos + 1, $p - $pos - 1);
            my $tmp = oct($oct_code);
            $m = {'str' => $str, 'from' => $pos, 'to' => $p, 'capture' => Perlito5::AST::Buf::->new('buf' => chr($tmp))}
        }
        elsif ($c2 eq 'N') {
            die('TODO - ' . chr(92) . 'N{charname} not implemented; requires ' . chr(39) . 'use charnames' . chr(39))
        }
        else {
            $m = {'str' => $str, 'from' => $pos, 'to' => $pos + 2, 'capture' => Perlito5::AST::Buf::->new('buf' => $c2)}
        }
        return $m
    }
    sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
        my $m_var = $_[0];
        my $interpolate = $_[1];
        my $str = $m_var->{'str'};
        my $pos = $m_var->{'to'};
        my $p = $pos;
        my $m_index;
        if (substr($str, $p, 3) eq '->[') {
            $p += 3;
            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
            $m_index || die('syntax error');
            my $exp = $m_index->{'capture'};
            $p = $m_index->{'to'};
            ($exp eq '*undef*' || substr($str, $p, 1) ne ']') && die('syntax error');
            $p++;
            $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<[ ]>', 'invocant' => $m_var->{'capture'}, 'arguments' => $exp);
            $m_index->{'to'} = $p;
            return double_quoted_var_with_subscript($m_index, $interpolate)
        }
        if (substr($str, $p, 3) eq '->{') {
            $pos += 2;
            $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
            $m_index || die('syntax error');
            $m_index->{'capture'} = Perlito5::AST::Call::->new('method' => 'postcircumfix:<{ }>', 'invocant' => $m_var->{'capture'}, 'arguments' => Perlito5::Match::flat($m_index)->[2]->[0]);
            return double_quoted_var_with_subscript($m_index, $interpolate)
        }
        if (substr($str, $p, 1) eq '[') {
            if ($interpolate == 2) {
                my $m = Perlito5::Grammar::Number::term_digit($str, $p + 1) || (substr($str, $p + 1, 1) eq '-' && Perlito5::Grammar::Number::term_digit($str, $p + 2)) || Perlito5::Grammar::Sigil::term_sigil($str, $p + 1);
                $m || return $m_var;
                substr($str, $m->{'to'}, 1) eq ']' || return $m_var
            }
            $p++;
            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
            if ($m_index) {
                my $exp = $m_index->{'capture'};
                $p = $m_index->{'to'};
                if ($exp ne '*undef*' && substr($str, $p, 1) eq ']') {
                    $p++;
                    my $value = $m_var->{'capture'};
                    if (ref($value) eq 'Perlito5::AST::Var') {
                        $value->{'_real_sigil'} = '@'
                    }
                    $m_index->{'capture'} = Perlito5::AST::Index::->new('obj' => $value, 'index_exp' => $exp);
                    $m_index->{'to'} = $p;
                    return double_quoted_var_with_subscript($m_index, $interpolate)
                }
            }
        }
        $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
        if ($m_index) {
            my $value = $m_var->{'capture'};
            if (ref($value) eq 'Perlito5::AST::Var') {
                $value->{'_real_sigil'} = '%'
            }
            $m_index->{'capture'} = Perlito5::AST::Lookup::->new('obj' => $value, 'index_exp' => Perlito5::Match::flat($m_index)->[2]->[0]);
            return double_quoted_var_with_subscript($m_index, $interpolate)
        }
        return $m_var
    }
    sub Perlito5::Grammar::String::double_quoted_var {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $_[2];
        my $interpolate = $_[3];
        my $c = substr($str, $pos, 1);
        if ($c eq '$' && substr($str, $pos + 1, 1) eq '{') {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            my $var = Perlito5::Match::flat($m)->[1];
            $m->{'capture'} = $var;
            return $m
        }
        elsif ($c eq '$' && substr($str, $pos + 1, 1) eq '$' && !Perlito5::Grammar::word($str, $pos + 2)) {
            return {'str' => $str, 'capture' => Perlito5::AST::Var::->new('name' => '$', 'sigil' => '$', 'namespace' => ''), 'from' => $pos, 'to' => $pos + 2}
        }
        elsif ($c eq '$' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            $m->{'capture'} = $m->{'capture'}->[1];
            return double_quoted_var_with_subscript($m, $interpolate)
        }
        elsif ($c eq '@' && substr($str, $pos + 1, length($delimiter)) ne $delimiter) {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            $m->{'capture'} = $m->{'capture'}->[1];
            $m = double_quoted_var_with_subscript($m, $interpolate);
            $m->{'capture'} = Perlito5::AST::Apply::->new('code' => 'join', 'arguments' => [Perlito5::AST::Var::->new('name' => '"', 'sigil' => '$', 'namespace' => ''), $m->{'capture'}], 'namespace' => '');
            return $m
        }
        return 0
    }
    Perlito5::Grammar::Precedence::add_term(chr(39) => \&term_q_quote);
    Perlito5::Grammar::Precedence::add_term('"' => \&term_qq_quote);
    Perlito5::Grammar::Precedence::add_term('/' => \&term_m_quote);
    Perlito5::Grammar::Precedence::add_term('<' => \&term_glob);
    Perlito5::Grammar::Precedence::add_term('<<>>' => \&term_glob);
    Perlito5::Grammar::Precedence::add_term('<<' => \&here_doc_wanted);
    Perlito5::Grammar::Precedence::add_term('`' => \&term_qx);
    Perlito5::Grammar::Precedence::add_term('m' => \&term_m_quote);
    Perlito5::Grammar::Precedence::add_term('q' => \&term_q_quote);
    Perlito5::Grammar::Precedence::add_term('qq' => \&term_qq_quote);
    Perlito5::Grammar::Precedence::add_term('qw' => \&term_qw_quote);
    Perlito5::Grammar::Precedence::add_term('qx' => \&term_qx);
    Perlito5::Grammar::Precedence::add_term('qr' => \&term_qr_quote);
    Perlito5::Grammar::Precedence::add_term('s' => \&term_s_quote);
    Perlito5::Grammar::Precedence::add_term('tr' => \&term_tr_quote);
    Perlito5::Grammar::Precedence::add_term('y' => \&term_tr_quote);
    1
}
;1
